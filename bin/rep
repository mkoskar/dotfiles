#!/usr/bin/env bash

set -eu

prgname=${0##*/}

_usage() {
    cat <<-EOF
	usage: $prgname [options] cmd [arg]...

	Execute 'cmd [arg]...' repeatedly.

	  -d delay  - wait for 'delay' milliseconds; <0 = wait forever, 0 = don't wait at all (default: 1000)
	  -t        - terminate if 'cmd' finished in less than 'delta' milliseconds
	  -T delta  - (default: 400)
	  -o output - redirect stdout and sterr to 'output'
	  -a        - don't truncate 'output' but do append instead
	  -i        - inline (don't use alternate screen)
	  -I        - don't hide cursor
	  -q        - quiet
	EOF
}
usage() { _usage; exit 0; }
usage_err() { _usage; exit 2; } >&2

# shellcheck disable=SC1007
dopt= Topt= output='/dev/null'
declare -i term=0 inline=0 cur=0 quiet=0
while getopts d:tT:o:aiIqh opt; do
    case $opt in
        d)
            [ "$OPTARG" -eq "$OPTARG" ] 2>/dev/null || {
                echo "$prgname: option requires an integer argument -- $opt" >&2
                usage_err
            }
            dopt=$OPTARG
            ;;
        t)
            term=1
            ;;
        T)
            [ "$OPTARG" -gt 0 ] 2>/dev/null || {
                echo "$prgname: option requires a positive integer argument -- $opt" >&2
                usage_err
            }
            Topt=$OPTARG
            ;;
        o)
            output=$OPTARG
            ;;
        a)
            append=1
            ;;
        i)
            inline=1
            ;;
        I)
            cur=1
            ;;
        q)
            quiet=1
            ;;
        h)
            usage
            ;;
        *)
            usage_err
            ;;
    esac
done
shift $((OPTIND-1))

(( $# )) || usage_err

# ----------------------------------------

delay=${dopt:-1000}
term_delta=${Topt:-400}

declare -i notty=0
if [[ ! -t 0 ]]; then
    if (( delay < 0 )); then
        echo "$prgname: stdin not being a tty doesn't go with negative delay" >&2
        exit 2
    fi
    notty=1
fi

tc=$(stty -g)
stty -icanon -echo

if (( delay > 0 )); then
    delay_s=$(bc -l <<<"scale=2; $delay/1000")
    read_opts=(-t "$delay_s")
fi

ti_ed=$(tput ed)
ti_el=$(tput el)
ti_rc=$(tput rc)

if (( ! inline )); then
    {
        echo -e "smcup\nclear\nsc\n"
        (( cur )) || echo civis
    } | tput -S
    cleanup() { tput -S <<<$'cnorm\nrmcup'; stty "$tc"; }
    trap cleanup EXIT
fi

declare -i long=0
while true; do
    ts_begin=$(date +%s.%N)
    ts_begin_=$(date +%T -d "@$ts_begin")

    (( ! inline )) && printf '%s' "$ti_rc"
    (( ! quiet )) && printf "> started: %s${ti_el}\n" "$ts_begin_" >&2
    (( ! inline && long )) && printf '%s' "$ti_ed"

    printf -v cmd '%q "$@"' "$1"
    bashx -c "$cmd" "$@" |& tee ${append+-a} "$output" | sed -r "s/\$/$ti_el/"

    ts_end=$(date +%s.%N)
    ts_end_=$(date +%T -d "@$ts_end")

    long=$(bc -l <<<"($ts_end-$ts_begin) > 1")

    if (( term )); then
        should_term=$(bc -l <<<"($ts_end-$ts_begin) < $term_delta/1000")
        (( should_term == 1 )) && break
    fi

    if (( notty && delay > 0 )); then
        (( ! inline )) && printf '%s' "$ti_ed"
        sleep "$delay_s"
        continue
    fi

    if (( delay != 0 )); then
        if (( ! quiet )); then
            h=
            (( delay > 0 )) && h="waiting for ${delay}ms, "
            h="${h}press any key to start or q|Q to quit"
            printf "> finished: %s (%s)${ti_el}\n" "$ts_end_" "$h" >&2
            (( ! inline )) && printf '%s' "$ti_ed"
        fi
        read -N1 -rs "${read_opts[@]}" c || continue
        case $c in [qQ]) break ;; esac
    fi
done
