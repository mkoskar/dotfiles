" vim: ft=vim fdm=marker

let vimrc = get(g:, 'vimrc', expand('<sfile>:p'))
let $MYVIMRC = vimrc


" Important
" ----------------------------------------

set nocompatible
set pastetoggle=<F6>

set rtp =
    \ rtp+=~/.vim
    \ rtp+=/usr/share/vim/vimfiles
    \ rtp+=$VIMRUNTIME
    \ rtp+=~/.vim/after

if has('nvim')
    call utils#rtpPrepend('~/.config/nvim')
endif

let bin = has('nvim') ? 'nvim' : 'vim'
let $VIMDIR = $HOME . '/.local/share/' . bin

if isdirectory($BASEDIR)
    call utils#rtpPrepend($BASEDIR . '/.vim')
    if has('nvim')
        call utils#rtpPrepend($BASEDIR . '/.nvim')
    endif
    let $VIMDIR = $BASEDIR . '/.' . bin
endif

let &pp = &rtp


" Moving Around, Searching and Patterns
" ----------------------------------------

set ignorecase
set incsearch
set paragraphs=
set path=.,,**
set sections=
set smartcase
set whichwrap=b,s,<,>,[,]

let mapleader = ','
let maplocalleader = ';'

noremap <M-,> ,
noremap <M-;> ;

noremap - ^
noremap <Tab> W
noremap <S-Tab> B

noremap <M-j> 5j
noremap <M-k> 5k

noremap <M-C-L> 5l
noremap <M-C-H> 5h
nmap <M-BS> <M-C-H>

noremap <C-E> 5<C-E>
noremap <C-Y> 5<C-Y>

noremap zl 5zl
noremap zh 5zh

nnoremap J <Cmd>exec 'move +' . v:count1<CR>
nnoremap K <Cmd>exec 'move -1-' . v:count1<CR>

xnoremap <silent> J :move '>+<C-R>=v:count1<CR><CR>gv
xnoremap <silent> K :move '<-1-<C-R>=v:count1<CR><CR>gv

nnoremap * <Cmd>let @/ = '\V\c\<' . escape(expand('<cword>'), '\/') . '\>' \| set hls<CR>
nnoremap g* <Cmd>let @/ = '\V\c' . escape(expand('<cword>'), '\/') \| set hls<CR>
nnoremap # <Cmd>let @/ = '\V\c\S\@<!' . escape(expand('<cWORD>'), '\/') . '\S\@!' \| set hls<CR>
nnoremap g# <Cmd>let @/ = '\V\c' . escape(expand('<cWORD>'), '\/') \| set hls<CR>
xnoremap g/ y<Cmd>let @/ = '\V\c' . escape(@", '\/') \| call histadd('search', @/) \| set hls<CR>

nnoremap <Leader>* <Cmd>let @/ = '\V\C\<' . escape(expand('<cword>'), '\/') . '\>' \| set hls<CR>
nnoremap <Leader>g* <Cmd>let @/ = '\V\C' . escape(expand('<cword>'), '\/') \| set hls<CR>
nnoremap <Leader># <Cmd>let @/ = '\V\C\S\@<!' . escape(expand('<cWORD>'), '\/') . '\S\@!' \| set hls<CR>
nnoremap <Leader>g# <Cmd>let @/ = '\V\C' . escape(expand('<cWORD>'), '\/') \| set hls<CR>
xnoremap <Leader>g/ y<Cmd>let @/ = '\V\C' . escape(@", '\/') \| call histadd('search', @/) \| set hls<CR>

function! s:SearchParagraph(mode, backward) abort
    for i in range(v:count1)
        let fold = a:backward ? foldclosed('.') : foldclosedend('.')
        if fold > 0
            call cursor(fold, a:backward ? 1 : col([fold, '$']))
        endif
        if a:mode == 0
            let pat = '\v(\n@1<=\n\_^\zs.)|%'
        elseif a:mode == 1
            let pat = '\v(\n@1<=\n\_^\zs.)|(^.+\n\n)|%'
        elseif a:mode == 2
            let pat = '\v(\n@1<=\n\_^\s*\zs.)|(.\n\n)|%'
        endif
        let pat .= a:backward ? '^' : '$'
        call search(pat, a:backward ? 'Wb' : 'W')
    endfor
endfunction

noremap <M-{> <Cmd>call <SID>SearchParagraph(0, 1)<CR>
noremap <M-}> <Cmd>call <SID>SearchParagraph(0, 0)<CR>
map <M-S-[> <M-{>
map <M-S-]> <M-}>

noremap <M-[> <Cmd>call <SID>SearchParagraph(2, 1)<CR>
noremap <M-]> <Cmd>call <SID>SearchParagraph(2, 0)<CR>


" Tags
" ----------------------------------------

set tags-=./tags tags-=./tags; tags^=./tags;

nnoremap <F12> <Cmd>call system('mktags') \| call utils#echoWarn('mktags finished')<CR>
nnoremap <Leader>lt :ltag /


" Displaying Text
" ----------------------------------------

set display=lastline
set list
set listchars=eol:¬,tab:>-,trail:-,extends:>,precedes:<,nbsp:+,conceal:_
set nowrap
set scrolloff=2
set showbreak=>
set sidescroll=10
set sidescrolloff=10

"set fillchars=fold:\ ,foldsep:│,vert:│
"set fillchars=fold:\ ,foldopen:⎡,foldclose:╾,foldsep:⎢,vert:│
"set fillchars=fold:\ ,foldopen:▍,foldclose:▊,foldsep:▏,vert:│
set fillchars=fold:\ ,foldopen:┑,foldclose:╾,foldsep:│,vert:│

nnoremap <Leader>L :setl <C-R>=&list ? 'nolist' : 'list'<CR><CR>
nnoremap <Leader>U :setl dy<C-R>=&dy =~# 'uhex' ? '-' : '+'<CR>=uhex<CR>
nnoremap <Leader>W :setl <C-R>=&wrap ? 'nowrap' : 'wrap'<CR><CR>


" Syntax, Highlighting and Spelling
" ----------------------------------------

set colorcolumn=80
set spelllang=en_us
set spelloptions=camel
set synmaxcol=500

if !&hlsearch | set hlsearch | endif

let c_comment_strings = 1
let load_doxygen_syntax = 1
let python_highlight_all = 1

nnoremap <Space> <Cmd>diffup! \| nohls \| echo<CR>
nnoremap <M-Space> <Cmd>let v:hlsearch = !v:hlsearch<CR>
nnoremap <Leader>ft <Cmd>filetype detect \| syn sync fromstart<CR>

nnoremap <Leader>cuc :setl <C-R>=&cuc ? 'nocuc' : 'cuc'<CR><CR>
nnoremap <Leader>cul :setl <C-R>=&cul ? 'nocul' : 'cul'<CR><CR>
nnoremap <Leader>cux :setl <C-R>=&cuc && &cul ? 'nocuc nocul' : 'cuc cul'<CR><CR>
nnoremap <Leader>sp :setl <C-R>=&spell ? 'nospell' : 'spell'<CR><CR>

function! s:ccToggle() abort
    if !empty(&l:cc)
        let w:cc = &l:cc
        let &l:cc = ''
    else
        let &l:cc = get(w:, 'cc', &g:cc)
    endif
    echo printf(':setl cc=%s', &l:cc)
endfunction

function! s:ccToggleColumn(col) abort
    if index(split(&l:cc, ','), string(a:col)) < 0
        exec 'setl cc+=' . a:col
    else
        exec 'setl cc-=' . a:col
    endif
    echo printf(':setl cc=%s', &l:cc)
endfunction

function! s:ccCycle() abort
    if !empty(&l:cc) && &l:cc != &g:cc
        let w:cc_cycle = &l:cc
        let &l:cc = &g:cc
    else
        let &l:cc = get(w:, 'cc_cycle', &g:cc)
    endif
    echo printf(':setl cc=%s', &l:cc)
endfunction

nnoremap <Leader>col <Cmd>call <SID>ccToggle()<CR>
nnoremap <Leader>coL <Cmd>call <SID>ccToggleColumn(virtcol('.'))<CR>
nnoremap <Leader>co< <Cmd>call <SID>ccCycle()<CR>

function! s:ColorsReset() abort
    if has('gui_running')
        colorscheme bclear
    else
        if &t_Co < 256
            colorscheme desert
        else
            colorscheme luciusblack
        endif
    endif
endfunction

command! -bar ColorsReset call s:ColorsReset()
command! -bar Hitest runtime syntax/hitest.vim


" Multiple Windows
" ----------------------------------------

set hidden
set laststatus=2
set splitbelow
set splitright
set winheight=5

let stlTail = '%6(%l:%v%) %P'
let stlTail .= "%( %{%
    \ argc() > 0
    \ ? (arglistid() == 0 ? '' : 'L')
        \ . (argv(argidx()) ==# bufname() ? '*' : '-')
        \ . (argidx() + 1) . '/' . argc()
        \ : ''
    \ %}%)"

let &g:stl = '%<%{' . expand('<SID>') . 'WinLabel(win_getid(), -20)}'
let &g:stl .= '%( [%M%W%R]%)'
let &g:stl .= '%( %y%)'
let &g:stl .= "%( [%{&l:fenc !=# 'utf-8' ? &l:fenc : ''}]%)"
let &g:stl .= "%( [%{&l:ff !=# 'unix' ? &l:ff : ''}]%)"
let &g:stl .= "%( %{get(b:, 'run_title', '')}%)"
let &g:stl .= "%( %{get(w:, 'quickfix_title', '')}%)"
let &g:stl .= '%=' . stlTail

nnoremap <C-J> <C-W>j
nnoremap <C-K> <C-W>k
nnoremap <C-L> <C-W>l
nnoremap <C-H> <C-W>h
nmap <BS> <C-H>

nnoremap s<C-J> <Cmd>below split<CR>
nnoremap s<C-K> <Cmd>above split<CR>
nnoremap s<C-L> <Cmd>rightb vsplit<CR>
nnoremap s<C-H> <Cmd>lefta vsplit<CR>
nmap s<BS> s<C-H>

nnoremap c<C-J> <Cmd>below new<CR>
nnoremap c<C-K> <Cmd>above new<CR>
nnoremap c<C-L> <Cmd>rightb vnew<CR>
nnoremap c<C-H> <Cmd>lefta vnew<CR>
nmap c<BS> c<C-H>

nnoremap <C-W>N <Cmd>vnew<CR>
nnoremap <C-W><C-N> <Cmd>vnew<CR>

nnoremap d<C-J> <C-W>j<C-W>c<C-W>p
nnoremap d<C-K> <C-W>k<C-W>c<C-W>p
nnoremap d<C-L> <C-W>l<C-W>c<C-W>p
nnoremap d<C-H> <C-W>h<C-W>c<C-W>p
nmap d<BS> d<C-H>

nnoremap <C-_> <C-W>_
nnoremap g<C-J> <C-W>j<C-W>_
nnoremap g<C-K> <C-W>k<C-W>_

nnoremap _ <Cmd>resize -5<CR>
nnoremap + <Cmd>resize +5<CR>
nnoremap <M--> <Cmd>vert resize -5<CR>
nnoremap <M-=> <Cmd>vert resize +5<CR>


" Multiple Tab Pages
" ----------------------------------------

set tabpagemax=50

let &g:tabline = '%!' . expand('<SID>') . 'TabLine1()'

" {{{

function! s:WinLabel(winid, width = 0) abort
    let wininfo = getwininfo(a:winid)[0]
    let width = (a:width > 0) ? a:width : max([8, get(wininfo, 'width') + a:width])
    let bufnr = get(wininfo, 'bufnr')
    let bt = getbufvar(bufnr, '&bt')
    let prefer_bufname = 1
    if empty(bt)
        let name = '[]'
    elseif bt ==# 'quickfix'
        let loclist = get(wininfo, 'loclist')
        let name = loclist ? '[loclist]' : '[qflist]'
        let prefer_bufname = 0
    elseif bt ==# 'terminal'
        let name = '[term]'
        let prefer_bufname = 0
    elseif bt ==# 'prompt'
        let name = '[prompt]'
    elseif bt ==# 'popup'
        let name = '[popup]'
    else
        let name = '[scratch]'
    endif
    let bufname = bufname(bufnr)
    if !empty(bufname) && prefer_bufname
        if empty(bt) || bt ==# 'nowrite'
            let name = simplify(fnamemodify(bufname, ':~:.'))
            if strcharlen(name) > width
                let name = substitute(name, '\v/\zs(.).{-}\ze/', '\1', 'g')
            endif
            let head = fnamemodify(name, ':h')
            let tail = fnamemodify(name, ':t')
            if head == '.'
                let name = ''
            elseif head == '/' || head == '//'
                let name = '/'
            else
                let name = head . '/'
            endif
            let tailw = max([8, width - strcharlen(name)])
            if tailw < strcharlen(tail)
                let tail = slice(tail, 0, tailw) . '…'
            endif
            let name .= tail
        elseif bt ==# 'help'
            let name = fnamemodify(bufname, ':t')
        else
            let name = bufname
            if name[0] == '/'
                let name = simplify(fnamemodify(name, ':~'))
            endif
        endif
    endif
    if getbufvar(bufnr, 'ft_tabline', 0)
        let name = printf('·%s·', getbufvar(bufnr, '&ft'))
    endif
    return name
endfunction

function! s:TabLabel(tabnr) abort
    let winnr = tabpagewinnr(a:tabnr)
    let winid = win_getid(winnr, a:tabnr)
    return s:WinLabel(winid, &co / 3)
endfunction

function! s:TabLine1() abort
    let [cur, last] = [tabpagenr(), tabpagenr('$')]
    let [beg, end] = [1, last]
    let [line, llen] = ['', 0]
    for i in range(beg, end)
        let name = s:TabLabel(i)
        let len = strcharlen(name) + len(i) + 3
        if llen + len > &co
                \ - (beg > 1) * 4
                \ - (i < last) * 3
                \ - len(cur) - len(last) - 1
                \ - 4
            if cur < i | break | endif
            let beg = i
            let [line, llen] = ['', 0]
        endif
        let end = i
        let llen += len
        let line .= (i == cur) ? '%#TabLineSel#' : '%#TabLine#'
        let line .= printf('%%%dT%d:%s%%T  ', i, i, substitute(name, '%', '%%', 'g'))
    endfor
    let tl = '%#TabLine#'
    if beg > 1 | let tl .= '<<  ' | endif
    let tl .= line . '%#TabLine#'
    if end < last | let tl .= '>> ' | endif
    let tl .= printf('%%=%d/%d', cur, last)
    let tl .= ' %999X[×]%X'
    return tl
endfunction

" }}}

nnoremap <M-1> 1gt
nnoremap <M-2> 2gt
nnoremap <M-3> 3gt
nnoremap <M-4> 4gt
nnoremap <M-5> 5gt
nnoremap <M-6> 6gt
nnoremap <M-7> 7gt
nnoremap <M-8> 8gt
nnoremap <M-9> 9gt

nnoremap <M-a> g<Tab>
nnoremap <M-0> <Cmd>tabfirst<CR>
nnoremap <M-^> <Cmd>tabfirst<CR>
nnoremap <M-$> <Cmd>tablast<CR>
nnoremap <M-(> <Cmd>tabfirst<CR>
nnoremap <M-)> <Cmd>tablast<CR>

nnoremap <M-h> gT
nnoremap <M-l> gt
nnoremap <M-H> <Cmd>silent! tabmove -1<CR>
nnoremap <M-L> <Cmd>silent! tabmove +1<CR>

nnoremap <M-n> <Cmd>tabnew<CR>
nnoremap <M-N> <Cmd>tab split<CR>

function! s:QuitTab(bang) abort
    try
        exec 'tabclose' . a:bang
    catch /:E784:/
        silent exec empty(a:bang) ? 'qall' : 'cquit'
    endtry
endfunction

command! -bang -bar QuitTab call utils#tryCatchCall('<SID>QuitTab', <q-bang>)
nnoremap QQ <Cmd>QuitTab<CR>
nnoremap QA <Cmd>QuitTab!<CR>


" Terminal
" ----------------------------------------

if !has('nvim')
    set keyprotocol+=tmux:mok2
    set termwinkey=<C-\\>
endif

tnoremap <C-\> <C-\><C-N>


" Using the Mouse
" ----------------------------------------

set mouse=

nnoremap <Leader>M :set mouse=<C-R>=empty(&mouse) ? 'a' : ''<CR><CR>


" TUI/GUI
" ----------------------------------------

set guicursor+=a:blinkon0
set guifont=Terminus\ 16px
set guioptions=ce
set title

let &titlestring = '%{v:progname}: '
let &titlestring .= '%<%{' . expand('<SID>') . 'WinLabel(win_getid())}'
let &titlestring .= "%( %{get(b:, 'run_title', '')}%)"
let &titlestring .= "%( %{get(w:, 'quickfix_title', '')}%)"

if !has('nvim')
    set nottybuiltin
    set ttyfast
    let &t_ut = ''
    let &t_EI = "\e[2 q"
    let &t_SR = "\e[4 q"
    let &t_SI = "\e[6 q"
    let &t_BE = "\e[?2004h"
    let &t_BD = "\e[?2004l"
    let &t_PS = "\e[200~"
    let &t_PE = "\e[201~"
endif

map! <S-Insert> <MiddleMouse>


" Messages and Info
" ----------------------------------------

set belloff=all
set ruler
set shortmess=aoOtTWI
set showcmd
set showmode


" Selecting Text
" ----------------------------------------

set clipboard=unnamed

"if has('nvim')
"    let clipboard = #{
"    \     name: 'xsel',
"    \     copy: {
"    \         '+': ['xsel', '--nodetach', '-i', '-b'],
"    \         '*': ['xsel', '--nodetach', '-i', '-p'],
"    \     },
"    \     paste: {
"    \         '+': ['xsel', '-o', '-b'],
"    \         '*': ['xsel', '-o', '-p'],
"    \     },
"    \     cache_enabled: 1,
"    \ }
"endif

nnoremap Y y$
nnoremap <expr> gp printf('`[%s`]', getregtype()[0])


" Editing Text
" ----------------------------------------

set backspace=indent,eol,start
set complete-=i
set completeopt=menuone,longest
set formatoptions=tcroqln21j
set matchpairs+=<:>
set nojoinspaces
set nrformats=alpha,hex,bin,unsigned
set showmatch
set textwidth=80
set tildeop
set undofile
set undolevels=100
"set undoreload=0

let &undodir = $VIMDIR . '/undo//'
call utils#mkdir(&undodir)

"nnoremap cw dwi
"nnoremap cW dWi

noremap <Leader><C-J> J
nnoremap <Leader>w :setl fo<C-R>=&fo =~# 't' ? '-' : '+'<CR>=t<CR>

inoremap <C-B> <Home>
inoremap <expr> <C-E> pumvisible() ? "\<C-E>" : "\<End>"
inoremap <M-h> <Left>
inoremap <M-l> <Right>
inoremap <M-b> <Cmd>call utils#moveWord(0)<CR>
inoremap <M-f> <Cmd>call utils#moveWord(1, 1)<CR>
inoremap <M-w> <Cmd>call utils#moveWord(1)<CR>

inoremap <C-U> <C-G>u<C-U>
inoremap <C-K> <C-G>u<C-\><C-O>d$
inoremap <C-W> <C-G>u<C-W>
inoremap <M-d> <C-G>u<C-\><C-O>d<Cmd>call utils#moveWord(1, 1)<CR>
inoremap <M-x> <Delete>

inoremap <M-j> <C-G>j
inoremap <M-k> <C-G>k

inoremap <C-_> <C-K>
inoremap <C-S-_> <C-K>
inoremap <M-e> <C-E>
inoremap <M-y> <C-Y>

inoremap <expr> <C-G><C-F> expand('%:t')
inoremap <expr> <C-G><C-P> expand('%:p')
inoremap <expr> <C-G><C-D> strftime('%c')
imap <C-G>f <C-G><C-F>
imap <C-G>p <C-G><C-P>
imap <C-G>d <C-G><C-D>

inoremap <C-F> <C-X><C-F>
inoremap <expr> <C-L> pumvisible() ? "\<C-L>" : "\<C-X>\<C-L>"

function! s:ClearUndo() abort
    if !&ma || &ro
        call utils#echoError("Ignoring: not 'modifiable' or 'readonly'")
        return
    endif
    let save = [&l:ul, &l:mod]
    try
        setl ul=-1
        exec "normal! a \<BS>\<Esc>"
    finally
        let [&l:ul, &l:mod] = save
    endtry
    if empty(&bt) || &bt ==# 'nowrite'
        let ufile = undofile(expand('%'))
        if !empty(ufile)
            call delete(ufile)
        endif
    endif
endfunction

command! -bar ClearUndo call s:ClearUndo()


" Tabs and Indenting
" ----------------------------------------

set autoindent
set copyindent
set expandtab
set preserveindent
set shiftwidth=0
set smartindent
set smarttab
set softtabstop=-1
set tabstop=4


" Folding
" ----------------------------------------

set foldcolumn=1
set foldminlines=0
set foldopen-=block

nnoremap <Leader>fc :setl fdc=<C-R>=&fdc != 0 ? '0' : '1'<CR><CR>
nnoremap <Leader>ff :setl fdm=manual<CR>
nnoremap <Leader>fi :setl fdm=indent fdn=2 \| normal! zM<CR>
nnoremap <Leader>fm :setl fdm=marker \| normal! zM<CR>
nnoremap <Leader>fs :setl fdm=syntax \| normal! zM<CR>


" Diff Mode
" ----------------------------------------

set diffopt+=algorithm:patience,foldcolumn:1


" Mapping
" ----------------------------------------

set ttimeout
set ttimeoutlen=10


" Reading and Writing Files
" ----------------------------------------

set autoread
set backup
set fileformats+=mac
set modeline

let &backupdir = $VIMDIR . '/backup//'
call utils#mkdir(&backupdir)


" The Swap File
" ----------------------------------------

set swapfile
set updatetime=300

let &directory = $VIMDIR . '/swap//'
call utils#mkdir(&directory)

function! s:Swap() abort
    let cur = swapname('%')
    if empty(cur) | return | endif
    let base = fnamemodify(cur, ':r')
    echo printf('%s.*', fnamemodify(base, ':~'))
    echo ' '
    let swpi = swapinfo(cur)
    echo printf('> %s%s (current)', fnamemodify(cur, ':e'), swpi.dirty ? ' [+]' : '')
    echo strftime('%c', swpi.mtime)
    echo ' '
    for f in glob(base . '.*', 1, 1)
        try
            if f ==# cur | continue | endif
            let swpi = swapinfo(f)
            echo printf('> %s%s', fnamemodify(f, ':e'), swpi.dirty ? ' [+]' : '')
            echo strftime('%c', swpi.mtime)
            echo printf('%s %s@%s (pid: %s)', swpi.version, swpi.user, swpi.host, swpi.pid)
            echo ' '
            let c = confirm('What to do?', "&Delete\n&Recover\n&Skip", 3)
            if c == 1
                call delete(f)
            elseif c == 2
                exec 'silent recover' fnameescape(f)
                echo ' '
                break
            endif
        catch /^\(Vim:Interrupt\)\@!.*/
            call utils#echoException()
        endtry
        echo ' '
    endfor
endfunction

command! -bar Swap call s:Swap()


" Command Line Editing
" ----------------------------------------

set history=1000
set suffixes=.bak,.swp,~
set wildcharm=<C-Z>
set wildmenu
set wildmode=lastused:longest:full,full

cnoremap <Left> <Space><BS><Left>
cnoremap <Right> <Space><BS><Right>
cnoremap <expr> <C-N> wildmenumode() ? "<C-N>" : "<Down>"
cnoremap <expr> <C-P> wildmenumode() ? "<C-P>" : "<Up>"

cnoremap <expr> <Tab> getcmdtype() =~ '[/?]' ? "<C-G>" : "<C-Z>"
cnoremap <expr> <S-Tab> getcmdtype() =~ '[/?]' ? "<C-T>" : (wildmenumode() ? "<S-Tab>" : "<C-Z>")
cmap <M-n> <Tab>
cmap <M-p> <S-Tab>

" <C-B> <Home>
" <C-E> <End>
cmap <M-h> <Left>
cmap <M-l> <Right>
cnoremap <expr> <M-b> getcmdtype() != '-' ? "<C-\>e utils#cmdlineMoveWord(0)<CR>" : ''
cnoremap <expr> <M-f> getcmdtype() != '-' ? "<C-\>e utils#cmdlineMoveWord(1, 1)<CR>" : ''
cnoremap <expr> <M-w> getcmdtype() != '-' ? "<C-\>e utils#cmdlineMoveWord(1)<CR>" : ''

" <C-U> - backward kill line
cnoremap <expr> <C-K> getcmdtype() != '-' ? "<C-\>e strpart(getcmdline(), 0, getcmdpos() - 1)<CR>" : ''
cnoremap <expr> <C-W> getcmdtype() != '-' ? "<C-\>e utils#cmdlineKillWord(0)<CR>" : ''
cnoremap <expr> <M-d> getcmdtype() != '-' ? "<C-\>e utils#cmdlineKillWord(1, 1)<CR>" : ''
cnoremap <M-x> <Delete>

cnoremap <C-_> <C-K>
cnoremap <C-S-_> <C-K>
cnoremap <C-O> <S-Tab>
cnoremap <expr> %% getcmdtype() != '-' ? "<C-R>=fnamemodify(expand('%:h'), ':~') . '/'<CR>" : '%%'
cnoremap <expr> %<Space> getcmdtype() != '-' ? '%' : "%<Space>"


" Executing External Commands
" ----------------------------------------

set shell=bashx
set shellredir=&>%s

noremap <Leader><C-K> K


" Running 'make' and Jumping To Errors
" ----------------------------------------

set grepformat=%f:%l:%c:%m,%f:%l:%m
set grepprg=internal
set shellpipe=\|&\ tee

nnoremap <F9> :make!<CR>

nnoremap <Leader>cl <Cmd>copen<CR>
nnoremap <Leader>ll <Cmd>lopen<CR>

nnoremap <Leader>J <Cmd>cnext<CR>
nnoremap <Leader>K <Cmd>cprev<CR>

function! s:LocOrQfCmd(cmd) abort
    try
        echo
        exec 'l' . a:cmd
    catch /:E\(42\|776\):/
        exec 'c' . a:cmd
    endtry
endfunction

nnoremap <Leader>j <Cmd>call utils#tryCatchCall('<SID>LocOrQfCmd', 'next')<CR>
nnoremap <Leader>k <Cmd>call utils#tryCatchCall('<SID>LocOrQfCmd', 'prev')<CR>

function! s:QfText(item2line) abort
    function! s:QfText_(ctx) closure abort
        let items = a:ctx.quickfix
            \ ? getqflist(#{id: a:ctx.id, items: 0}).items
            \ : getloclist(a:ctx.winid, #{id: a:ctx.id, items: 0}).items
        let lines = []
        for idx in range(a:ctx.start_idx - 1, a:ctx.end_idx - 1)
            call add(lines, a:item2line(items[idx]))
        endfor
        return lines
    endfunction
    return function('s:QfText_')
endfunction

function! s:QfFiles(loclist, action, files_func, title) abort
    let SetList = a:loclist ? function('setloclist', [0]) : function('setqflist')
    call SetList([], a:action, #{
        \ nr: a:action == ' ' ? '$' : 0,
        \ efm: '%f',
        \ lines: a:files_func(),
        \ title: a:title,
        \ quickfixtextfunc: s:QfText({i -> fnamemodify(bufname(i.bufnr), ':p:~')}),
        \ context: #{reload_func: function('s:QfFiles', [a:loclist, 'r', a:files_func, a:title])},
        \ })
    exec a:loclist ? 'lopen' : 'copen'
endfunction

command! -bang -bar Cargs call s:QfFiles(0, empty(<q-bang>) ? ' ' : 'r', {-> argv(-1, -1)}, ':Cargs')
command! -bang -bar Largs call s:QfFiles(1, empty(<q-bang>) ? ' ' : 'r', {-> argv()}, ':Largs')
command! -bang -bar OldFiles call s:QfFiles(0, empty(<q-bang>) ? ' ' : 'r', {-> v:oldfiles}, ':OldFiles')

function! s:QfSystem(loclist, action, cmd, title = '!' . a:cmd) abort
    let SetList = a:loclist ? function('setloclist', [0]) : function('setqflist')
    call SetList([], a:action, #{
        \ nr: a:action == ' ' ? '$' : 0,
        \ lines: systemlist(a:cmd),
        \ title: a:title,
        \ quickfixtextfunc: 0,
        \ context: #{reload_func: function('s:QfSystem', [a:loclist, 'r', a:cmd, a:title])},
        \ })
    exec a:loclist ? 'lopen' : 'copen'
endfunction

function! s:QfGrep(loclist, action, args) abort
    call s:QfSystem(a:loclist, a:action,
                    \ 'grep -rnH --exclude-dir=.git ' . a:args,
                    \ printf(':%sgrep %s', a:loclist ? 'L' : 'C', a:args))
endfunction

command! -nargs=* -bang Cgrep call s:QfGrep(0, empty(<q-bang>) ? ' ' : 'r', <q-args>)
command! -nargs=* CgrepAdd call s:QfGrep(0, 'a', <q-args>)
command! -nargs=* -bang Lgrep call s:QfGrep(1, empty(<q-bang>) ? ' ' : 'r', <q-args>)
command! -nargs=* LgrepAdd call s:QfGrep(1, 'a', <q-args>)

function! s:QfRg(loclist, action, args) abort
    call s:QfSystem(a:loclist, a:action,
                    \ 'rg --vimgrep --no-ignore ' . a:args,
                    \ printf(':%srg %s', a:loclist ? 'L' : 'C', a:args))
endfunction

command! -nargs=* -bang Crg call s:QfRg(0, empty(<q-bang>) ? ' ' : 'r', <q-args>)
command! -nargs=* CrgAdd call s:QfRg(0, 'a', <q-args>)
command! -nargs=* -bang Lrg call s:QfRg(1, empty(<q-bang>) ? ' ' : 'r', <q-args>)
command! -nargs=* LrgAdd call s:QfRg(1, 'a', <q-args>)

function! s:QfAg(loclist, action, args) abort
    call s:QfSystem(a:loclist, a:action,
                    \ 'ag --vimgrep ' . a:args,
                    \ printf(':%srg %s', a:loclist ? 'L' : 'C', a:args))
endfunction

command! -nargs=* -bang Cag call s:QfAg(0, empty(<q-bang>) ? ' ' : 'r', <q-args>)
command! -nargs=* CagAdd call s:QfAg(0, 'a', <q-args>)
command! -nargs=* -bang Lag call s:QfAg(1, empty(<q-bang>) ? ' ' : 'r', <q-args>)
command! -nargs=* LagAdd call s:QfAg(1, 'a', <q-args>)


" Language Specific
" ----------------------------------------

silent! set keymap=slovak

set iminsert=0
set imsearch=-1


" Various
" ----------------------------------------

set signcolumn=yes
set virtualedit=block

let &viewdir = $VIMDIR . '/view'
let &viminfo = "!,'100,<50,s10,h"
let &viminfofile = $VIMDIR . '/viminfo'

cabbrev vv verbose

nnoremap <C-W><C-F> <Cmd>vert wincmd f<CR>
nnoremap <Leader><C-L> <C-L>
nnoremap <Leader>D <Cmd>%d<CR>
nnoremap <Leader>la :ls!<CR>
nnoremap <Leader>lb :ls! %<CR>
nnoremap <Leader>lc :ls! +<CR>
nnoremap <Leader>ls :ls<CR>
nnoremap <Leader>lt :ls t<CR>
nnoremap <Leader>q <Cmd>close<CR>
nnoremap <Leader>ve :setl ve=<C-R>=&ve =~# 'all' ? 'block' : 'all'<CR><CR>

" Switch to Ex mode with gQ instead
nnoremap Q <NOP>

" Select mode is annoying
nnoremap g<BS> <NOP>
nnoremap g<C-H> <NOP>
nnoremap gH <NOP>
nnoremap gh <NOP>
xnoremap <C-G> <NOP>

" New lines
nnoremap [<Space> O<Esc>'[
nnoremap ]<Space> o<Esc>

" Open
nnoremap <Leader>ew :e<Space>
nnoremap <Leader>es :sp<Space>
nnoremap <Leader>ev :vs<Space>
nnoremap <Leader>et :tabe<Space>
nnoremap <Leader>ee <Cmd>e<CR>
nnoremap <Leader>e0 <Cmd>e ++bin<CR>
nnoremap <Leader>e1 <Cmd>e ++nobin<CR>
nnoremap <Leader>E <Cmd>e!<CR>

" Read / Filter
nnoremap <Leader>% :%!
nnoremap <Leader>ri :r!

" Readonly / Modifiable
nnoremap <Leader>ro :setl ro noma<CR>
nnoremap <Leader>ma :setl ma noro<CR>

" Sorting
xnoremap <silent> <Leader>ss :sort<CR>
xnoremap <silent> <Leader>su :sort u<CR>
xnoremap <silent> <Leader>sr :sort!<CR>
xnoremap <silent> <Leader>sb :!sortb<CR>

" Strip / Squash lines
xnoremap <silent> <Leader>ps :!striplns<CR>
nnoremap <silent> <Leader>ps :%!striplns<CR>
xnoremap <silent> <Leader>pS :!squashlns<CR>
nnoremap <silent> <Leader>pS :%!squashlns<CR>

" Help
nnoremap <Leader>h :tab help<Space>
nnoremap <Leader>H :tab lhelpgrep<Space>

" Diffs
xnoremap <silent> <Leader>do :diffget<CR>
nnoremap <silent> <Leader>do :.diffget<CR>
xnoremap <silent> <Leader>dp :diffput<CR>
nnoremap <silent> <Leader>dp :.diffput<CR>
nnoremap <Leader>du <Cmd>diffup!<CR>
nnoremap <Leader>dc <Cmd>diffoff!<CR>
nnoremap <Leader>dd <Cmd>exec &diff ? 'diffoff' : 'diffthis'<CR>

command! -bar Scratch <mods> new +setl\ bt=nofile\ bh=wipe\ noswf\ nobl
nnoremap <Leader>ss <Cmd>Scratch<CR>
nnoremap <Leader>sv <Cmd>vert Scratch<CR>

command! -range -bar Vis normal! <line1>GV<line2>G

command! -range=% -bar Rev Keep <line1>,<line2> g/^/m<line1>-1

" ----------------------------------------

" :Args - Prints out bang, range, and arguments {{{

function! s:Args(bang, mods, ...) range abort
    echo printf('bang: %d', !empty(a:bang))
    echo printf('mods: %s', a:mods)
    echo printf('range: %d,%d', a:firstline, a:lastline)
    for idx in range(a:0)
        echo printf('%d : %s', idx+1, a:000[idx])
    endfor
endfunction

command! -nargs=* -range -bang Args <line1>,<line2>
    \ call s:Args(<q-bang>, <q-mods>, <f-args>)

" }}}

" :Bdelete - Better :bdelete {{{

function! s:Bdelete(bang, rbeg, rend, ...) abort
    let newbuf = -1
    for bufref in empty(a:000) ? range(a:rbeg, a:rend) : a:000
        if type(bufref) == v:t_string && match(bufref, '^\d\+$') >= 0
            let bufref = str2nr(bufref)
        endif
        let target_buf = bufnr(bufref)
        if target_buf < 0
            call utils#echoError(printf('E94: No matching buffer for %s', bufref))
            continue
        endif
        if !bufloaded(target_buf)
            continue
        endif
        if empty(a:bang) && getbufvar(target_buf, '&mod')
            call utils#echoError(printf('E89: No write since last change for buffer %s (add ! to override)', target_buf))
            continue
        endif
        let srcwin = win_getid()
        for win in win_findbuf(target_buf)
            let [tab, winnr] = win_id2tabwin(win)
            let [jumps, jumpi] = getjumplist(winnr, tab)
            let [i, dstbuf] = [jumpi - 1, -1]
            while i >= 0
                let buf = jumps[i].bufnr
                if buf > 0 && buf != target_buf && bufloaded(buf)
                    let dstbuf = buf
                    break
                endif
                let i -= 1
            endwhile
            if dstbuf < 0
                if newbuf < 0 | let newbuf = bufadd('') | endif
                let &l:buflisted = 1
                let dstbuf = newbuf
            endif
            call win_gotoid(win)
            exec 'buffer' dstbuf
        endfor
        exec 'bdelete' . a:bang target_buf
        call win_gotoid(srcwin)
    endfor
endfunction

command! -nargs=* -range -addr=loaded_buffers -bang -complete=buffer
    \ Bdelete call s:Bdelete(<q-bang>, <line1>, <line2>, <f-args>)
nnoremap <C-Q> <Cmd>Bdelete!<CR>

" }}}

" :DiffTo - Start diff of current buffer with another file {{{

function! s:DiffTo(file) abort
    let file = fnamemodify(a:file, ':p')
    if isdirectory(file)
        call utils#echoError(printf('"%s" is a directory', fnamemodify(file, ':h')))
        return
    endif
    if !filereadable(file)
        call utils#echoError(printf('"%s" is not readable', file))
        return
    endif
    vnew
    exec 'read ++edit' fnameescape(file) | 0d_
    exec 'setl bt=nofile bh=wipe noswf nobl noma ft=' . getbufvar('#', '&ft')
    exec 'silent file DiffTo:\ ' . fnameescape(fnamemodify(file, ':~'))
    diffthis
    wincmd p
    diffthis
endfunction

command! -nargs=1 -complete=file DiffTo call s:DiffTo(<q-args>)
nnoremap <Leader>df :DiffTo <C-R>=expand('%')<CR>

" }}}

" :Execute :System :SystemRegister :SystemRange :Reload :ReloadT - Capture command's output {{{

function! s:Run(system, cmd, input, mode = 1, mods = '') abort
    if a:system
        let out = system(a:cmd, a:input)
        let reg = 's'
    else
        try
            let list = &l:list
            let &l:list = 0
            let out = execute(a:cmd)[1:]
        finally
            let &l:list = list
        endtry
        let reg = 'e'
    endif
    call setreg(reg, out, 'l')
    if a:mode < 0
        if !empty(out)
            "call append(line('.'), getreg(reg, 1, 1))
            exec 'put' reg
        endif
        return
    endif
    if a:mode > 0
        exec a:mods 'new'
    endif
    setl bt=nofile bh=hide noswf nobl
    let b:run_system = a:system
    let b:run_cmd = a:cmd
    let b:run_input = a:input
    let b:run_title = (a:system ? '!' : ':') . a:cmd
    try
        let [_ma, _ro, _ul] = [&l:ma, &l:ro, &l:ul]
        setl ma noro ul=-1
        silent exec 'Keep %d_ | put' reg '| 1d_'
        if !a:system | %Sanitize | endif
    catch /:E353:/
    finally
        let [&l:ma, &l:ro, &l:ul] = [_ma, _ro, _ul]
        let v:statusmsg = b:run_title
    endtry
endfunction

command! -nargs=1 -count=1 -bang -complete=command Execute
    \ call utils#tryCatchCall('<SID>Run', 0, <q-args>, [], empty(<q-bang>) ? <count> > 0 : -1, <q-mods>)
nnoremap <Leader>xe :Execute<Space>
nnoremap <Leader>xE :Execute!<Space>

command! -nargs=1 -count=1 -bang -complete=shellcmd System
    \ call utils#tryCatchCall('<SID>Run', 1, <q-args>, [], empty(<q-bang>) ? <count> > 0 : -1, <q-mods>)
command! -nargs=1 -bang -complete=shellcmd SystemRegister
    \ call utils#tryCatchCall('<SID>Run', 1, <q-args>, getreg(v:register, 1, 1), empty(<q-bang>) ? 1 : -1, <q-mods>)
command! -nargs=1 -range -bang -complete=shellcmd SystemRange
    \ call utils#tryCatchCall('<SID>Run', 1, <q-args>, getline(<line1>, <line2>), empty(<q-bang>) ? 1 : -1, <q-mods>)
nnoremap <Leader>xs :System<Space>
nnoremap <Leader>xS :System!<Space>
xnoremap <Leader>xs y:SystemRegister<Space>
xnoremap <Leader>xS y:SystemRegister!<Space>

function! s:Reload(bang) abort
    if exists('b:run_system')
        call s:Run(b:run_system, b:run_cmd, b:run_input, 0)
    else
        if &l:buftype =~# '^\(nofile\|quickfix\|terminal\)$'
            throw printf("\"%s\" buffer can't be reloaded", &l:buftype)
        endif
        silent exec 'Keep edit' . a:bang
    endif
    redraw
    let v:statusmsg = printf('[%s] %s', strftime('%H:%M:%S'), v:statusmsg)
    echo utils#shortenCmdline(v:statusmsg)
endfunction

command! -bang -bar Reload call utils#tryCatchCall('<SID>Reload', <q-bang>)
nnoremap <Leader>rr <Cmd>Reload<CR>

function! s:ReloadT(bang, d) abort
    let d = str2nr(a:d)
    let d = d == 0 ? 1 : d
    try
        let v:statusmsg = ''
        while 1
            call s:Reload('')
            echon printf(' (every %ds)', d)
            if !empty(a:bang) | silent $ | endif
            exec 'sleep' d
        endwhile
    finally
        redraw
        echo utils#shortenCmdline(v:statusmsg)
    endtry
endfunction

command! -nargs=? -bang -bar ReloadT call utils#tryCatchCall('<SID>ReloadT', <q-bang>, <q-args>)
nnoremap <Leader>R <Cmd>ReloadT<CR>
nnoremap <Leader>F <Cmd>ReloadT!<CR>

" }}}

" :Format - Format with :!format {{{

function! s:Format(ft = &ft) range abort
    let args = [a:firstline . ',' . a:lastline, '!format', '-s', &sw, '-t', &tw]
    if !empty(a:ft) | call extend(args, ['-f', a:ft]) | endif
    exec join(args)
endfunction

command! -nargs=? -range -bar Format silent Keep <line1>,<line2> call s:Format(<f-args>)
xnoremap <silent> <Leader>fo :Format<CR>
nnoremap <silent> <Leader>fo :%Format<CR>

xnoremap <silent> <Leader>px :Format xml<CR>
nnoremap <silent> <Leader>px :%Format xml<CR>

xnoremap <silent> <Leader>pj :Format json<CR>
nnoremap <silent> <Leader>pj :%Format json<CR>

" }}}

" :Keep - Keep cursor/window position, last search pattern, and others {{{

function! s:Keep(cmd) abort
    let view = winsaveview()
    try
        exec 'keepa keepj keepm keepp' a:cmd
    finally
        call winrestview(view)
    endtry
endfunction

command! -nargs=1 -complete=command Keep call utils#tryCatchCall('<SID>Keep', <q-args>)

" }}}

" :MetaToggle - Toggle meta/alt key handling mode {{{

" See also: `:set termcap`

function! s:MetaSetup(mode = -1) abort
    let mode = a:mode >= 0 ? a:mode : get(g:, 'meta', 0)
    for c in map(range(1, 126), 'nr2char(v:val)')
        if stridx('|"', c) >= 0
            let c = '\' . c
        elseif stridx("\x09\x0a\x16 >[", c) >= 0
            continue
        endif
        let kc = printf('<M-%s>', c)
        exec printf('set %s=%s', kc, mode > 0 ? "\e" . c : '')
        "if empty(maparg(kc, 'i')) | exec printf('inoremap %s <NOP>', kc) | endif
        "if empty(maparg(kc, 'c')) | exec printf('cnoremap %s <NOP>', kc) | endif
    endfor
    let g:meta = mode > 0
    if !has('vim_starting')
        redraw
        " See also: `man 1 kbdinfo`
        call utils#echoWarn('meta: ' . (g:meta ? 'escprefix' : 'metabit'))
    endif
endfunction

command! -bar MetaToggle call s:MetaSetup(!get(g:, 'meta', 0))
nnoremap <Leader>mm <Cmd>MetaToggle<CR>

" }}}

" :MoveToNextTab :MoveToPrevTab - Move window to next/prev tab {{{

function! s:MoveToTab(next) abort
    if tabpagenr('$') == 1 && winnr('$') == 1 | return | endif
    let [tab, srcwin] = [tabpagenr(), win_getid()]
    if a:next ? tab < tabpagenr('$') : tab > 1
        exec a:next ? 'tabnext' : 'tabprev'
        botright vsplit
    else
        if winnr('$') == 1 | return | endif
        exec a:next ? 'tabnew' : '0tabnew'
    endif
    exec 'buffer' winbufnr(srcwin)
    let dstwin = win_getid()
    call win_gotoid(srcwin)
    close!
    call win_gotoid(dstwin)
endfunction

command! -bar MoveToNextTab call s:MoveToTab(1)
command! -bar MoveToPrevTab call s:MoveToTab(0)
nnoremap <C-W><M-l> <Cmd>MoveToNextTab<CR>
nnoremap <C-W><M-h> <Cmd>MoveToPrevTab<CR>

" }}}

" :NextClosedFold :PrevClosedFold - Move to next/prev closed fold {{{
" See also: https://stackoverflow.com/questions/9403098/is-it-possible-to-jump-to-closed-folds-in-vim

function! s:MoveToClosedFold(next) abort
    let cmd = 'normal! z' . (a:next ? 'j' : 'k')
    let view = winsaveview()
    let [lnum0, lnum, isopen] = [0, view.lnum, 1]
    while lnum != lnum0 && isopen
        exec cmd
        let [lnum0, lnum] = [lnum, line('.')]
        let isopen = foldclosed(lnum) < 0
    endwhile
    if isopen | call winrestview(view) | endif
endfunction

command! -bar NextClosedFold call s:MoveToClosedFold(1)
command! -bar PrevClosedFold call s:MoveToClosedFold(0)
nnoremap zJ <Cmd>NextClosedFold<CR>
nnoremap zK <Cmd>PrevClosedFold<CR>

" }}}

" :Option :BufWinOptions - Display options {{{

" global (e.g., 'cdpath')
"   - &g:opt and &l:opt is a single value
"
" local to buffer (e.g., 'readonly')
"   - &g:opt is a single value
"   - &l:opt is assigned to a buffer
"
" local to window (e.g., 'list')
"   - &g:opt is assigned to a window
"   - &l:opt is assigned to a window-buffer pair
"
" global or local to buffer (e.g., 'path')
"   - &g:opt is a single value
"   - &l:opt is assigned to a buffer with fallback to &g:opt
"
" global or local to window (e.g., 'statusline')
"   - &g:opt is a single value
"   - &l:opt is assigned to a window, with fallback to &g:opt
"
" --------------------------------------------------
"
" :set opt
"   - set both &g:opt and &l:opt
"   - in case of global-local option set &g:opt and reset &l:opt
"
" :set opt<
"   - let &l:opt = &g:opt
"   - in case of global-local option reset &l:opt
"
" :setl opt<
"   - let &l:opt = &g:opt

function! s:Option(opt) abort
    if exists('&' . a:opt)
        echo printf('&g:%s=%s', a:opt, eval('&g:' . a:opt))
        echo printf('&l:%s=%s', a:opt, eval('&l:' . a:opt))
    else
        call utils#echoError(printf('"%s" is not an option', a:opt))
    endif
endfunction

command! -nargs=1 -bar -complete=option Option call s:Option(<q-args>)
nnoremap <Leader>oo :Option<Space>

function! s:BufOrWinOptions(getvar) abort
    for opt in sort(keys(a:getvar('&')))
        let g = a:getvar('&g:' . opt)
        let l = a:getvar('&l:' . opt)
        if type(g) == v:t_number
            echo printf('%-15s%10s%10s', opt, g, l)
        else
            echo printf("%-15s\n  =%s\n  =%s", opt, g, l)
        endif
    endfor
endfunction

function! s:BufAndWinOptions() abort
    echo 'Buffer options (global/local):'
    echo '----------------------------------------'
    call s:BufOrWinOptions(function('getbufvar', ['']))
    echon "\n"
    echo 'Window options (global/local):'
    echo '----------------------------------------'
    call s:BufOrWinOptions(function('getwinvar', [0]))
endfunction

command! -count=1 -bar BufWinOptions <count>Execute call s:BufAndWinOptions()

" }}}

" :Register - Edit registers {{{

function! s:Register(regname, value) abort
    let regname = a:regname
    if empty(regname)
        let regname = '"'
        if &clipboard =~# 'unnamed' | let regname = '*' | endif
        if &clipboard =~# 'unnamedplus' | let regname = '+' | endif
    endif
    let value = substitute(a:value, '^=', '', '')
    call setreg(regname, value, 'c')
endfunction

command! -nargs=? -register Register call s:Register(<q-reg>, <q-args>)
nnoremap <Leader>re :Register <C-R>=v:register<CR> =<C-R>=getreg(v:register)<CR>

" }}}

" :Themes - Walk through list of colorschemes {{{

function! s:Themes() abort
    let themes = ['luciusblack', 'hybrid', 'bclear']
    let [i, lasti] = [get(s:, 'themes_last_index'), len(themes) - 1]
    try
        while 1
            exec 'colorscheme' themes[i]
            redraw | echo themes[i]
            let c = getcharstr()
            if stridx("\<C-C>\<Esc>q", c) >= 0
                break
            elseif c ==# 'k'
                let i = i > 0 ? i - 1 : lasti
            else
                let i = i < lasti ? i + 1 : 0
            endif
        endwhile
        let s:themes_last_index = i
    finally
        redraw | echo
    endtry
endfunction

command! -bar Themes call s:Themes()
nnoremap <Leader>th <Cmd>Themes<CR>

" }}}

" :ToText - Convert to text with :!totext {{{

function! s:ToText(ft = &ft) range abort
    let args = [a:firstline . ',' . a:lastline, '!totext', '-s', &sw, '-t', &tw]
    if !empty(a:ft) | call extend(args, ['-f', a:ft]) | endif
    exec join(args)
endfunction

command! -nargs=? -range=% -bar ToText silent <line1>,<line2> call s:ToText(<f-args>)

" }}}

" :VimrcReload - Edit/Reload vimrc {{{

nnoremap <silent> <Leader>rc :tabe <C-R>=fnameescape(vimrc)<CR><CR>

try
function! s:VimrcReload() abort
    let winrestcmd = winrestcmd()

    new +setl\ bt=nofile\ bh=wipe\ noswf\ nobl
    exec 'source' fnameescape(g:vimrc)
    close

    "let winid = popup_create('VimrcReload', #{hidden: 1})
    "call win_execute(winid, 'source ' . fnameescape(g:vimrc))
    "call popup_close(winid)

    "let winids = map(getwininfo(), 'v:val.winid')
    "for opt in keys(getwinvar(0, '&'))
    "   let val = getwinvar(0, '&g:' . opt)
    "   for winid in winids
    "       call win_execute(winid, printf('let &g:%s = %s', opt, string(val)))
    "   endfor
    "endfor

    exec winrestcmd
    redraw | call utils#echoWarn('vimrc reloaded')
endfunction
catch /:E127:/
endtry

command! -bar VimrcReload call s:VimrcReload()
nnoremap <Leader>so <Cmd>VimrcReload<CR>

" }}}

" :W - Write with elevated privileges {{{

function! s:WriteShellCb(job, data, event) dict
    if a:event ==# 'exit'
        let s:Write.writing = 0
        return
    endif
    if !s:Write.writing | return | endif
    let part = get(s:Write, 'part_' . a:event , '')
    let [lines, part] = utils#channelLines(a:data, part)
    exec 'let s:Write.part_' . a:event '= part'
    if empty(lines) | return | endif
    for line in lines
        if a:event ==# 'stdout'
            let m = matchlist(line, s:Write.seq . '\t\(\d\+\)')
            if !empty(m)
                let s:Write.writing = 0
                call delete(s:Write.if)
                if m[1] > 0
                    try
                        call inputsave()
                        echomsg join(s:Write.errors, "\n")
                        call getchar()
                    finally
                        call inputrestore()
                        redraw
                    endtry
                else
                    if s:Write.of == expand('%:p')
                        exec 'silent wundo' fnameescape(undofile(s:Write.of))
                        silent edit!
                    endif
                    redraw
                    echo printf('%s written', fnamemodify(s:Write.of, ':~'))
                    checktime
                endif
            endif
        elseif a:event ==# 'stderr'
            let m = matchlist(line, s:Write.seq . '\t\(.*\)')
            if !empty(m)
                let prompt = join(s:Write.errors + [m[1] . ': '], "\n")
                let s:Write.errors = []
                try
                    call inputsave()
                    let passwd = inputsecret(prompt)
                finally
                    call inputrestore()
                    redraw
                endtry
                call chansend(s:Write.shell, passwd . "\n")
            else
                let s:Write.errors += [line]
            endif
        endif
    endfor
endfunction

function! s:Write(mods, filename = expand('%')) abort
    let filename = fnamemodify(a:filename, ':p')
    if empty(filename)
        call utils#echoError('E471: Argument required')
        return
    endif
    if isdirectory(filename) || filename =~# '[\t\n]'
        call utils#echoError('E474: Invalid argument')
        return
    endif
    let verbose = a:mods =~# 'verbose'
    if has('nvim')
        let s:Write = get(s:, 'Write', {})
        if get(s:Write, 'writing', 0)
            call utils#echoError('Writing in progress')
            return
        endif
        if exists('s:Write.shell')
            if jobwait([s:Write.shell], 0)[0] != -1
                call jobstop(s:Write.shell)
                unlet s:Write.shell
            endif
        endif
        if !exists('s:Write.shell')
            let s:Write.shell = jobstart(['sudowrite'], #{
                \ on_stdout: function('s:WriteShellCb'),
                \ on_stderr: function('s:WriteShellCb'),
                \ on_exit: function('s:WriteShellCb')
                \ })
            let s:Write.seq = rand()
        endif
        let s:Write.seq += 1
        let s:Write.writing = 1
        let s:Write.errors = []
        let s:Write.if = tempname()
        let s:Write.of = filename
        exec 'silent write' fnameescape(s:Write.if)
        call chansend(s:Write.shell, printf("%d\t%s\t%s\n", s:Write.seq, s:Write.if, s:Write.of))
        return
    else
        if verbose
            exec 'write !sudo -p "[sudo \%p as \%U]: " dd of=' . shellescape(filename, 1)
        else
            exec 'silent write !sudo -p "[sudo \%p as \%U]: " &>/dev/null dd of=' . shellescape(filename, 1)
        endif
    endif
    if v:shell_error
        if !verbose
            redraw
            call utils#echoError(printf('shell returned %d', v:shell_error))
        endif
    else
        if filename == expand('%:p')
            exec 'silent wundo' fnameescape(undofile(filename))
            silent edit!
        endif
        if !verbose | redraw | endif
        echo printf('%s written', fnamemodify(filename, ':~'))
        checktime
    endif
endfunction

command! -nargs=? -bar -complete=file W call s:Write(<q-mods>, <f-args>)

" }}}

" :ZoomToggle - Zoom/Restore window {{{

function! s:ZoomToggle() abort
    if get(t:, 'zoomed')
        exec t:zoom_winrestcmd
        let t:zoomed = 0
    else
        let t:zoom_winrestcmd = winrestcmd()
        resize
        vert resize
        let t:zoomed = 1
    endif
endfunction

command! -bar ZoomToggle call s:ZoomToggle()
nnoremap <M-m> <Cmd>ZoomToggle<CR>
nnoremap <M-z> <Cmd>ZoomToggle<CR>

" }}}

" ----------------------------------------

" Carve search pattern quickly {{{

function! s:SearchCarve(mode = '-') abort
    let mode = !empty(a:mode) ? a:mode : '-'
    let pat = '[^[:keyword:]]'
    let new = expand('<cWORD>')
    let cur = exists('b:SearchCarve') ? utils#commonPrefix(new, b:SearchCarve) : new
    if a:mode == '0'
        let cur = ''
    elseif a:mode == '$'
        let cur = new
    elseif stridx('hH', a:mode) >= 0
        for pass in [0, 1]
            let idx = match(cur, '.*\zs' . pat)
            if idx < 0
                let cur = ''
            elseif idx < len(cur) - 1
                let cur = cur[:idx]
            elseif idx == 0
                let cur = ''
            else
                if pass == (a:mode ==# 'H')
                    let cur = cur[:-2]
                endif
                continue
            endif
            break
        endfor
    elseif stridx('lL', a:mode) >= 0
        let idx = match(new, pat, len(cur))
        if idx < 0
            let cur = new
        elseif idx == len(cur)
            let cur = new[:idx]
        else
            let cur = new[:idx - (a:mode ==# 'L')]
        endif
    elseif a:mode ==# 'j'
        let cur = slice(cur, 0, -1)
    elseif a:mode ==# 'k'
        let cur .= strcharpart(new, strcharlen(cur), 1, 1)
    endif
    let b:SearchCarve = cur
    let @/ = '\V\(\^\|\s\+\)\zs' . escape(cur, '\/')
endfunction

function! s:SearchCarveI() abort
    set hls
    match Cursor /\%#/
    call s:SearchCarve()
    try
        while 1
            redraw | echo printf('%s', @/)
            let c = getcharstr()
            if stridx("\<C-C>\<C-J>\<CR>\<Esc>\<Space>q", c) >= 0
                break
            elseif stridx('0g', c) >= 0
                call s:SearchCarve('0')
            elseif stridx('$G/', c) >= 0
                call s:SearchCarve('$')
            elseif stridx('hHlLjk', c) >= 0
                call s:SearchCarve(c)
            elseif c ==? 'v'
                SearchSelect
                break
            elseif c ==? 'f'
                SearchSelect fold
                break
            elseif c ==? 'd'
                SearchSelect delete
                break
            endif
        endwhile
    finally
        match
        redraw | echo
    endtry
endfunction

function! s:SearchCarveI2() abort
    let b:SearchCarveI2 = {}
    call utils#mapSave(['d', 'q', 'v', 'zf'], 'x', b:SearchCarveI2)
    xnoremap d <Cmd>SearchSelect delete<CR>
    xnoremap q <Esc>
    xnoremap <silent> v :<C-U>SearchSelect<CR>
    xnoremap zf <Cmd>SearchSelect fold<CR>
    "normal! v
    call s:SearchCarveI2_update()
    augroup SearchCarveI2
        autocmd!
        autocmd CursorMoved * call s:SearchCarveI2_update()
        autocmd ModeChanged * call s:SearchCarveI2_end()
    augroup END
endfunction

function! s:SearchCarveI2_update() abort
    let pos1 = getpos('.')
    let pos2 = getpos('v')
    if pos1[1] != pos2[1]
        normal! o
        let pos2[1] = pos1[1]
        call setpos('.', pos2)
        let pos2 = getpos('.')
        normal! o
    endif
    let sel = getregion(pos1, pos2)
    let @/ = '\V' . escape(sel[0], '\/')
endfunction

function! s:SearchCarveI2_end() abort
    autocmd! SearchCarveI2
    call utils#mapRestore(b:SearchCarveI2)
endfunction

nnoremap <Leader>/ <Cmd>call utils#tryCatchCall('<SID>SearchCarveI')<CR>
"nnoremap <Leader>/ <Cmd>set hls \| call utils#tryCatchCall('<SID>SearchCarveI2')<CR>
"xnoremap <Leader>/ <Cmd>set hls \| call utils#tryCatchCall('<SID>SearchCarveI2')<CR>

" }}}

" Execute register in visual mode {{{

function! s:VisualAt() range abort
    redraw | echo '@'
    try
        exec a:firstline ',' a:lastline 'normal! @' . getcharstr()
    finally
        redraw | echo
    endtry
endfunction

xnoremap @ :norm!@
xnoremap <silent> @ :call utils#tryCatchCallRange('<SID>VisualAt')<CR>

" }}}

" Select lines that match the last search pattern {{{

function! s:SearchSelect(cmd = '') abort
    let cur = line('.')
    if getline(cur) !~# @/ | return | endif
    let idx = cur
    while getline(idx - 1) =~# @/ | let idx -= 1 | endwhile
    let [beg, idx] = [idx, cur]
    while getline(idx + 1) =~# @/ | let idx += 1 | endwhile
    if empty(a:cmd)
        exec printf('normal! %dGV%dG', beg, idx)
    else
        exec beg ',' idx a:cmd
    endif
endfunction

command! -nargs=* SearchSelect call s:SearchSelect(<q-args>)
nnoremap gV <Cmd>SearchSelect<CR>

" }}}

" ----------------------------------------

command! -nargs=? -range Split
    \ call utils#tryCatch(
    \     printf('Keep <line1>,<line2> s/%s/\r/ge',
    \         !empty(<q-args>) ? escape(<q-args>, '/') : '\s\+'
    \     )
    \ )

command! -nargs=? -range Join
    \ call utils#tryCatch(
    \     printf('Keep <line1>,%ds/\n/%s/ge',
    \         <line2> > <line1> ? <line2> - 1 : <line2>,
    \         !empty(<q-args>) ? escape(<q-args>, '/&') : ' '
    \     )
    \ )

command! -count=1 -bar PackPath exec '<count>Execute set pp' | exec 'normal! df=' | Split,

command! -count=1 -bar RuntimePath exec '<count>Execute set rtp' | exec 'normal! df=' | Split,

nnoremap <Leader>rg :Execute registers<CR>

command! -range=% -bar DelDirs Keep <line1>,<line2> g/\/$/d

command! -range -bar Sanitize silent Keep <line1>,<line2> s/\s\+$//e
xnoremap <silent> <Leader>pp :Sanitize<CR>
nnoremap <silent> <Leader>pp :%Sanitize<CR>

nnoremap <Leader>== <Cmd>Keep normal! gg=G<CR>
nnoremap <Leader>gq <Cmd>Keep normal! gggqG<CR>

xnoremap <silent> <Leader>uu :SystemRange! urls -o<CR>
nnoremap <silent> <Leader>uu :.SystemRange! urls -o<CR>
nnoremap <silent> <Leader>uU :<C-R>=line('w0')<CR>,<C-R>=line('w$')<CR>SystemRange! urls -o<CR>

xnoremap <silent> <Leader>uy :SystemRange! urls -y<CR>
nnoremap <silent> <Leader>uy :.SystemRange! urls -y<CR>
nnoremap <silent> <Leader>uY :<C-R>=line('w0')<CR>,<C-R>=line('w$')<CR>SystemRange! urls -y<CR>

nnoremap <Leader>gs :vert System git show HEAD:./

" ----------------------------------------

let loaded_2html_plugin = 1
let loaded_getscriptPlugin = 1
let loaded_logiPat = 1
let loaded_manpager_plugin = 1
let loaded_netrwPlugin = 1
let loaded_rrhelper = 1
let loaded_spellfile_plugin = 1
let loaded_vimballPlugin = 1

if has('nvim')
    let loaded_man = 1
    let loaded_remote_plugins = 1
    let loaded_tutor_mode_plugin = 1
endif

let qf_disable_statusline = 1

packadd! ansiesc
packadd! cfilter
packadd! colorschemes
packadd! matchit
packadd! termdebug

filetype plugin indent on
if !exists('syntax_on')
    syntax enable
endif

ColorsReset

augroup vimrc_base
    autocmd!

    autocmd BufEnter,BufWinEnter * match none
    autocmd FileChangedRO * setl noro

    autocmd CmdwinEnter *
        \  call utils#bufSpecial()
        \| noremap <buffer> <C-J> <C-C><C-E>

    autocmd BufReadPost *
        \  if line("'\"") >= 1 && line("'\"") <= line('$') && &ft !~# 'commit'
        \|     exec 'normal! g`"'
        \| endif

    autocmd SwapExists * let v:swapchoice = 'o' | setl noma

    function! s:TerminalSetup() abort
        call utils#bufSpecial()
        setl list
        let &l:stl = '%{%' . expand('<SID>') . 'TerminalStatusline()%}'
    endfunction

    function! s:TerminalStatusline() abort
        let stl = '%n'
        let bin = matchstr(expand('%'), '\v^term://%(.{-}//%(\d+:)?)?\zs.*')
        if empty(bin)
            let stl .= ' %<%f'
        else
            if bin ==# exepath(&shell) | let bin = &shell | endif
            let stl .= printf(' !%s', bin)
        endif
        if exists('b:term_title') && match(b:term_title, '^term://') < 0
            let stl .= printf(' [%s]', b:term_title)
        endif
        if mode() ==# 'n'
            let stl .= '%= %6(%l:%v%) %P'
        endif
        return stl
    endfunction

    if has('nvim')
        autocmd TermOpen,TermLeave * call s:TerminalSetup()
        autocmd TermOpen * startinsert
        autocmd TermEnter * setl nolist
    else
        autocmd TerminalWinOpen * call s:TerminalSetup()
        autocmd TermChanged * silent call s:MetaSetup()
    endif

    autocmd BufWritePost conky.conf !killall -USR1 conky
    autocmd BufWritePost ~/.Xresources !xrdb -screen -load ~/.Xresources

    autocmd FileType diff call utils#bufPlain()
    autocmd FileType mail call utils#bufPlain() | setl tw=72
    autocmd FileType make setl ts=4 noet
    autocmd FileType man call utils#bufPlain() | setl noma ts=8
    autocmd FileType rst setl ts=8 sw=3 fdm=manual foldtext&
    autocmd FileType tar call utils#bufPlain()
    autocmd FileType yaml setl ts=2
    autocmd FileType zip call utils#bufPlain()
    autocmd FileType {c,cpp}{,.*} let &l:path = '.,,**,/usr/include'
augroup END
