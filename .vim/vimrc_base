" vim: ft=vim fdm=marker

let vimrc = get(g:, 'vimrc', expand('<sfile>:p'))
let $MYVIMRC = vimrc


" Important
" ----------------------------------------

set nocompatible
set pastetoggle=<F6>

set rtp =
    \ rtp+=~/.vim
    \ rtp+=/usr/share/vim/vimfiles
    \ rtp+=$VIMRUNTIME
    \ rtp+=~/.vim/after

if has('nvim')
    call utils#rtpPrepend('~/.config/nvim')
endif

let bin = has('nvim') ? 'nvim' : 'vim'
let $VIMDIR = $HOME . '/.local/share/' . bin

if isdirectory($BASEDIR)
    call utils#rtpPrepend($BASEDIR . '/.vim')
    if has('nvim')
        call utils#rtpPrepend($BASEDIR . '/.nvim')
    endif
    let $VIMDIR = $BASEDIR . '/.' . bin
endif

let &pp = &rtp


" Moving Around, Searching and Patterns
" ----------------------------------------

set ignorecase
set incsearch
set path=.,,**
set smartcase
set whichwrap=b,s,<,>,[,]

let mapleader = ','
let maplocalleader = ';'

noremap <M-,> ,
noremap <M-;> ;

noremap - ^

" à la /_CTRL-L
vnoremap <C-L> l

noremap <M-j> 5j
noremap <M-k> 5k

noremap <M-C-L> 5l
noremap <M-C-H> 5h
nmap <M-BS> <M-C-H>

noremap <C-E> 5<C-E>
noremap <C-Y> 5<C-Y>

noremap zl 5zl
noremap zh 5zh

nnoremap J <Cmd>exec 'move +' . v:count1<CR>
nnoremap K <Cmd>exec 'move -1-' . v:count1<CR>

xnoremap <silent> J :move '>+<C-R>=v:count1<CR><CR>gv
xnoremap <silent> K :move '<-1-<C-R>=v:count1<CR><CR>gv

nnoremap * <Cmd>let @/ = '\V\<' . escape(expand('<cword>'), '\/') . '\>' \| set hls<CR>
nnoremap g* <Cmd>let @/ = '\V' . escape(expand('<cword>'), '\/') \| set hls<CR>
nnoremap # <Cmd>let @/ = '\V\S\@<!' . escape(expand('<cWORD>'), '\/') . '\S\@!' \| set hls<CR>
nnoremap g# <Cmd>let @/ = '\V' . escape(expand('<cWORD>'), '\/') \| set hls<CR>
xnoremap g/ y<Cmd>let @/ = '\V' . escape(@", '\/') \| call histadd('search', @/) \| set hls<CR>


" Tags
" ----------------------------------------

set tags-=./tags tags-=./tags; tags^=./tags;

nnoremap <F12> <Cmd>call system('mktags') \| call utils#echoWarn('mktags finished')<CR>
nnoremap <Leader>lt :ltag /


" Displaying Text
" ----------------------------------------

set display=lastline
set fillchars=
set list
set listchars=eol:¬,tab:>-,trail:-,extends:>,precedes:<,nbsp:+,conceal:_
set nowrap
set scrolloff=2
set sidescroll=10
set sidescrolloff=10

nnoremap <Leader>L :setl <C-R>=&list ? 'nolist' : 'list'<CR><CR>
nnoremap <Leader>U :setl display<C-R>=&display =~# 'uhex' ? '-' : '+'<CR>=uhex<CR>
nnoremap <Leader>W :setl <C-R>=&wrap ? 'nowrap' : 'wrap'<CR><CR>


" Syntax, Highlighting and Spelling
" ----------------------------------------

set colorcolumn=80
set hlsearch
set spelllang=en_us
set spelloptions=camel
set synmaxcol=200

let c_comment_strings = 1
let load_doxygen_syntax = 1
let python_highlight_all = 1

nnoremap <Space> <Cmd>nohls \| diffup!<CR><C-L>
nnoremap <Leader>ft <Cmd>filetype detect \| syn sync fromstart<CR>

nnoremap <Leader>cuc :setl <C-R>=&cuc ? 'nocuc' : 'cuc'<CR><CR>
nnoremap <Leader>cul :setl <C-R>=&cul ? 'nocul' : 'cul'<CR><CR>
nnoremap <Leader>cux :setl <C-R>=&cuc && &cul ? 'nocuc nocul' : 'cuc cul'<CR><CR>
nnoremap <Leader>sp :setl <C-R>=&spell ? 'nospell' : 'spell'<CR><CR>

function! s:ccToggle() abort
    if !empty(&l:cc)
        let w:cc = &l:cc
        let &l:cc = ''
    else
        let &l:cc = get(w:, 'cc', &g:cc)
    endif
    call utils#echo(printf(':setl cc=%s', &l:cc))
endfunction

function! s:ccToggleColumn(col) abort
    if index(split(&l:cc, ','), string(a:col)) < 0
        exec 'setl cc+=' . a:col
    else
        exec 'setl cc-=' . a:col
    endif
    call utils#echo(printf(':setl cc=%s', &l:cc))
endfunction

function! s:ccCycle() abort
    if !empty(&l:cc) && &l:cc != &g:cc
        let w:cc_cycle = &l:cc
        let &l:cc = &g:cc
    else
        let &l:cc = get(w:, 'cc_cycle', &g:cc)
    endif
    call utils#echo(printf(':setl cc=%s', &l:cc))
endfunction

nnoremap <Leader>col <Cmd>call <SID>ccToggle()<CR>
nnoremap <Leader>coL <Cmd>call <SID>ccToggleColumn(virtcol('.'))<CR>
nnoremap <Leader>co< <Cmd>call <SID>ccCycle()<CR>

function! s:ColorsReset() abort
    if has('gui_running')
        colorscheme bclear
    else
        if &t_Co < 256
            colorscheme desert
        else
            colorscheme luciusblack
        endif
    endif
endfunction

command! -bar ColorsReset call s:ColorsReset()
command! -bar Hitest call s:MetaLess('silent runtime syntax/hitest.vim')


" Multiple Windows
" ----------------------------------------

set hidden
set laststatus=2
set splitbelow
set splitright
set winheight=5

set statusline=
    \ statusline+=%n
    \ statusline+=\ %<%f
    \ statusline+=%(\ [%M%W%R]%)
    \ statusline+=%(\ %y%)
    \ statusline+=%(\ [%{&l:fenc!='utf-8'?&l:fenc:''}]%)
    \ statusline+=%(\ [%{&l:ff!='unix'?&l:ff:''}]%)
    \ statusline+=%(\ %{get(b:,'run_title','')}%)
    \ statusline+=%(\ %{get(w:,'quickfix_title','')}%)
    \ statusline+=%=
    \ statusline+=\ %6(%l:%v%)
    \ statusline+=\ %P
    \ statusline+=\%(\ %{%
            \argc()>0
                \?(arglistid()==0?'':'L')
                \.(argv(argidx())==bufname()?'*':'-')
                \.(argidx()+1).'/'.argc()
                \:''
        \%}%)

nnoremap <C-J> <C-W>j
nnoremap <C-K> <C-W>k
nnoremap <C-L> <C-W>l
nnoremap <C-H> <C-W>h
nmap <BS> <C-H>

nnoremap s<C-J> <Cmd>below split<CR>
nnoremap s<C-K> <Cmd>above split<CR>
nnoremap s<C-L> <Cmd>rightb vsplit<CR>
nnoremap s<C-H> <Cmd>lefta vsplit<CR>
nmap s<BS> s<C-H>

nnoremap c<C-J> <Cmd>below new<CR>
nnoremap c<C-K> <Cmd>above new<CR>
nnoremap c<C-L> <Cmd>rightb vnew<CR>
nnoremap c<C-H> <Cmd>lefta vnew<CR>
nmap c<BS> c<C-H>

nnoremap <C-W>N <Cmd>vnew<CR>
nnoremap <C-W><C-N> <Cmd>vnew<CR>

nnoremap d<C-J> <C-W>j<C-W>c<C-W>p
nnoremap d<C-K> <C-W>k<C-W>c<C-W>p
nnoremap d<C-L> <C-W>l<C-W>c<C-W>p
nnoremap d<C-H> <C-W>h<C-W>c<C-W>p
nmap d<BS> d<C-H>

nnoremap <C-_> <C-W>_
nnoremap g<C-J> <C-W>j<C-W>_
nnoremap g<C-K> <C-W>k<C-W>_

nnoremap _ <Cmd>resize -5<CR>
nnoremap + <Cmd>resize +5<CR>
nnoremap <M--> <Cmd>vert resize -5<CR>
nnoremap <M-=> <Cmd>vert resize +5<CR>


" Multiple Tab Pages
" ----------------------------------------

set tabpagemax=50

nnoremap <M-1> 1gt
nnoremap <M-2> 2gt
nnoremap <M-3> 3gt
nnoremap <M-4> 4gt
nnoremap <M-5> 5gt
nnoremap <M-6> 6gt
nnoremap <M-7> 7gt
nnoremap <M-8> 8gt
nnoremap <M-9> 9gt

nnoremap <M-a> g<Tab>
nnoremap <M-0> <Cmd>tabfirst<CR>
nnoremap <M-^> <Cmd>tabfirst<CR>
nnoremap <M-$> <Cmd>tablast<CR>
nnoremap <M-(> <Cmd>tabfirst<CR>
nnoremap <M-)> <Cmd>tablast<CR>

nnoremap <M-h> gT
nnoremap <M-l> gt
nnoremap <M-H> <Cmd>silent! tabmove -1<CR>
nnoremap <M-L> <Cmd>silent! tabmove +1<CR>

nnoremap <M-n> <Cmd>tabnew<CR>
nnoremap <M-N> <Cmd>tab split<CR>

function! s:QuitTab(bang) abort
    try
        exec 'tabclose' . a:bang
    catch /:E784:/
        silent exec empty(a:bang) ? 'qall' : 'cquit'
    endtry
endfunction

command! -bang -bar QuitTab call utils#tryCatchCall('<SID>QuitTab', <q-bang>)
nnoremap QQ <Cmd>QuitTab<CR>
nnoremap QA <Cmd>QuitTab!<CR>


" Terminal
" ----------------------------------------

if !has('nvim')
    set termwinkey=<C-\\>
endif

tnoremap <C-\> <C-\><C-N>


" Using the Mouse
" ----------------------------------------

set mouse=

nnoremap <Leader>M :set <C-R>=!empty(&mouse) ? 'mouse=' : 'mouse=a'<CR><CR>


" TUI/GUI
" ----------------------------------------

set title
set guicursor+=a:blinkon0
set guifont=Terminus\ 16px

set guioptions=
    \ guioptions+=c
    \ guioptions+=e
    \ guioptions-=L
    \ guioptions-=T
    \ guioptions-=m
    \ guioptions-=r

set titlestring=
    \ titlestring+=%{v:progname}:
    \ titlestring+=\ %n
    \ titlestring+=\ %<%f
    \ titlestring+=%(\ [%M%W%R]%)
    \ titlestring+=%(\ %y%)
    \ titlestring+=%(\ [%{&l:fenc!='utf-8'?&l:fenc:''}]%)
    \ titlestring+=%(\ [%{&l:ff!='unix'?&l:ff:''}]%)
    \ titlestring+=%(\ %{get(b:,'run_title','')}%)
    \ titlestring+=%(\ %{get(w:,'quickfix_title','')}%)

if !has('nvim')
    set nottybuiltin
    set ttyfast
    let &t_ut = ''
    let &t_EI = "\e[2 q"
    let &t_SR = "\e[4 q"
    let &t_SI = "\e[6 q"
    let &t_BE = "\e[?2004h"
    let &t_BD = "\e[?2004l"
    let &t_PS = "\e[200~"
    let &t_PE = "\e[201~"
endif

map! <S-Insert> <MiddleMouse>


" Messages and Info
" ----------------------------------------

set belloff=all
set ruler
set shortmess=aoOtTWIF
set showcmd
set showmode


" Selecting Text
" ----------------------------------------

set clipboard=unnamed

if has('nvim')
    let g:clipboard = {
        \   'name': 'xsel',
        \   'copy': {
        \     '+': ['xsel', '--nodetach', '-i', '-b'],
        \     '*': ['xsel', '--nodetach', '-i', '-p'],
        \   },
        \   'paste': {
        \     '+': ['xsel', '-o', '-b'],
        \     '*': ['xsel', '-o', '-p'],
        \   },
        \   'cache_enabled': 1,
        \ }
endif

nnoremap Y y$
nnoremap <expr> gp printf('`[%s`]', getregtype()[0])


" Editing Text
" ----------------------------------------

set backspace=indent,eol,start
set complete-=i
set completeopt=menuone,longest
set formatoptions=tcroqln21j
set matchpairs+=<:>
set nojoinspaces
set nrformats=alpha,hex,bin,unsigned
set showmatch
set textwidth=80
set tildeop
set undofile

let &undodir = $VIMDIR . '/undo//'
call utils#mkdir(&undodir)

noremap <Leader><C-J> J

inoremap <C-B> <Home>
inoremap <expr> <C-E> pumvisible() ? "\<C-E>" : "\<End>"
inoremap <M-h> <Left>
inoremap <M-l> <Right>
inoremap <M-b> <Cmd>call utils#moveWord(0)<CR>
inoremap <M-f> <Cmd>call utils#moveWord(1, 1)<CR>
inoremap <M-w> <Cmd>call utils#moveWord(1)<CR>

inoremap <C-U> <C-G>u<C-U>
inoremap <C-K> <C-G>u<C-\><C-O>d$
inoremap <C-W> <C-G>u<C-W>
inoremap <M-d> <C-G>u<C-\><C-O>d<Cmd>call utils#moveWord(1, 1)<CR>
inoremap <M-x> <Delete>

inoremap <M-j> <C-G>j
inoremap <M-k> <C-G>k

inoremap <C-_> <C-K>
inoremap <M-e> <C-E>
inoremap <M-y> <C-Y>

inoremap <expr> <C-G><C-F> expand('%:t')
inoremap <expr> <C-G><C-P> expand('%:p')
inoremap <expr> <C-G><C-d> strftime('%c')
imap <C-G>f <C-G><C-F>
imap <C-G>p <C-G><C-P>
imap <C-G>d <C-G><C-D>

inoremap <C-F> <C-X><C-F>
inoremap <expr> <C-L> pumvisible() ? "\<lt>C-L>" : "\<lt>C-X>\<lt>C-L>"


" Tabs and Indenting
" ----------------------------------------

set autoindent
set copyindent
set expandtab
set preserveindent
set shiftwidth=4
set smartindent
set smarttab
set tabstop=4


" Folding
" ----------------------------------------

set foldopen-=block

nnoremap <Leader>ff :setl fdm=manual \| normal! zE<CR>
nnoremap <Leader>fi :setl fdm=indent fdn=2 \| normal! zM<CR>
nnoremap <Leader>fm :setl fdm=marker \| normal! zM<CR>
nnoremap <Leader>fs :setl fdm=syntax \| normal! zM<CR>


" Diff Mode
" ----------------------------------------

set diffopt+=algorithm:patience


" Mapping
" ----------------------------------------

set ttimeout
set ttimeoutlen=10


" Reading and Writing Files
" ----------------------------------------

set autoread
set backup
set fileformats+=mac
set modeline

let &backupdir = $VIMDIR . '/backup//'
call utils#mkdir(&backupdir)


" The Swap File
" ----------------------------------------

set swapfile
set updatetime=300

let &directory = $VIMDIR . '/swap//'
call utils#mkdir(&directory)


" Command Line Editing
" ----------------------------------------

set history=1000
set suffixes=.bak,.swp,~
set wildcharm=<S-Tab>
set wildmenu
set wildmode=lastused:longest:full,full

cnoremap <Left> <Space><BS><Left>
cnoremap <Right> <Space><BS><Right>
cnoremap <expr> <C-N> wildmenumode() ? "\<C-N>" : "\<Down>"
cnoremap <expr> <C-P> wildmenumode() ? "\<C-P>" : "\<Up>"
cnoremap <M-n> <C-G>
cnoremap <M-p> <C-T>

" <C-B> <Home>
" <C-E> <End>
cmap <M-h> <Left>
cmap <M-l> <Right>
cnoremap <M-b> <C-\>e utils#cmdlineMoveWord(0)<CR>
cnoremap <M-f> <C-\>e utils#cmdlineMoveWord(1, 1)<CR>
cnoremap <M-w> <C-\>e utils#cmdlineMoveWord(1)<CR>

" <C-U> - backward kill line
cnoremap <C-K> <C-\>e strpart(getcmdline(), 0, getcmdpos()-1)<CR>
cnoremap <C-W> <C-\>e utils#cmdlineKillWord(0)<CR>
cnoremap <M-d> <C-\>e utils#cmdlineKillWord(1, 1)<CR>
cnoremap <M-x> <Delete>

cnoremap <C-_> <C-K>
cnoremap <C-O> <S-Tab>
cnoremap <expr> %% expand('%:h') . '/'


" Executing External Commands
" ----------------------------------------

set shell=bashx
set shellredir=&>%s


" Running 'make' and Jumping To Errors
" ----------------------------------------

" grep
set grepformat=%f:%l:%m
set grepprg=grep\ -nH\ --exclude-dir=.git\ --exclude=\*.swp\ --exclude=\*~\ $*

" ag / rg
set grepformat=%f:%l:%c:%m
set grepprg=ag\ --vimgrep\ $*
set grepprg=rg\ --vimgrep\ $*

set shellpipe=\|&\ tee

nnoremap <F9> :make!<CR>

nnoremap <Leader>cl <Cmd>copen<CR>
nnoremap <Leader>ll <Cmd>lopen<CR>

nnoremap <Leader>J <Cmd>cnext<CR>
nnoremap <Leader>K <Cmd>cNext<CR>

function! s:LocOrQfMove(dir) abort
    try
        echo
        exec 'l' . a:dir
    catch /:E\(42\|776\):/
        exec 'c' . a:dir
    endtry
endfunction

nnoremap <Leader>j <Cmd>call utils#tryCatchCall('<SID>LocOrQfMove', 'next')<CR>
nnoremap <Leader>k <Cmd>call utils#tryCatchCall('<SID>LocOrQfMove', 'prev')<CR>


" Language Specific
" ----------------------------------------

silent! set keymap=slovak

set iminsert=0
set imsearch=-1


" Various
" ----------------------------------------

set signcolumn=yes
set virtualedit=block

let &viewdir = $VIMDIR . '/view'
let &viminfo = "!,'100,<50,s10,h"
let &viminfofile = $VIMDIR . '/viminfo'

nnoremap Q <Nop>
nnoremap <Leader>V :setl <C-R>=&virtualedit =~# 'all' ? 'virtualedit=block' : 'virtualedit=all'<CR><CR>
nnoremap <C-Q> <Cmd>bd<CR>
nnoremap <silent> <C-W><C-F> :vsplit <C-R><C-P><CR>
nnoremap <Leader>D <Cmd>%d<CR>
nnoremap <Leader>q <Cmd>close<CR>
nnoremap <Leader>sc <Cmd>new +setl\ bt=nofile\ bh=wipe\ noswf\ nobl<CR>
nnoremap <Leader>ls :ls<CR>
nnoremap <Leader>la :ls!<CR>

nnoremap [<Space> O<Esc>'[
nnoremap ]<Space> o<Esc>

" Open
nnoremap <Leader>ew :e<Space>
nnoremap <Leader>es :sp<Space>
nnoremap <Leader>ev :vs<Space>
nnoremap <Leader>et :tabe<Space>
nnoremap <Leader>ee <Cmd>e \| f<CR>
nnoremap <Leader>e0 <Cmd>e ++bin \| f<CR>
nnoremap <Leader>e1 <Cmd>e ++nobin \| f<CR>
nnoremap <Leader>E <Cmd>e! \| f<CR>

" Read / Filter
nnoremap <Leader>% :%!
nnoremap <Leader>ri :r!

" Readonly / Modifiable
nnoremap <Leader>ro :setl ro noma<CR>
nnoremap <Leader>ma :setl ma noro<CR>

" Sorting
xnoremap <silent> <Leader>ss :sort<CR>
xnoremap <silent> <Leader>su :sort u<CR>
xnoremap <silent> <Leader>sr :sort!<CR>
xnoremap <silent> <Leader>sb :!sortb<CR>

" Strip / Squash lines
xnoremap <silent> <Leader>ps :!striplns<CR>
nnoremap <silent> <Leader>ps :%!striplns<CR>
xnoremap <silent> <Leader>pS :!squashlns<CR>
nnoremap <silent> <Leader>pS :%!squashlns<CR>

" Help
nnoremap <Leader>h :tab help<Space>
nnoremap <Leader>H :tab lhelpgrep<Space>

" Diffs
xnoremap <silent> <Leader>do :diffget<CR>
nnoremap <silent> <Leader>do :.diffget<CR>
xnoremap <silent> <Leader>dp :diffput<CR>
nnoremap <silent> <Leader>dp :.diffput<CR>
nnoremap <Leader>du <Cmd>diffup!<CR>
nnoremap <Leader>dc <Cmd>diffoff!<CR>
nnoremap <Leader>dd <Cmd>exec &diff ? 'diffoff' : 'diffthis'<CR>

" ----------------------------------------

" Better :bdelete {{{

function! s:Bdelete(bang, rbeg, rend, ...) abort
    let newbuf = -1
    for bufref in empty(a:000) ? range(a:rbeg, a:rend) : a:000
        if type(bufref) == v:t_string && match(bufref, '^\d\+$') >= 0
            let bufref = str2nr(bufref)
        endif
        let target_buf = bufnr(bufref)
        if target_buf < 0
            call utils#echoError(printf('E94: No matching buffer for %s', bufref))
            continue
        endif
        if !bufloaded(target_buf)
            continue
        endif
        if empty(a:bang) && getbufvar(target_buf, '&mod')
            call utils#echoError(printf('E89: No write since last change for buffer %s (add ! to override)', target_buf))
            continue
        endif
        let srcwin = win_getid()
        for win in win_findbuf(target_buf)
            let [tab, winnr] = win_id2tabwin(win)
            let [jumps, jumpi] = getjumplist(winnr, tab)
            let [i, dstbuf] = [jumpi-1, -1]
            while i >= 0
                let buf = jumps[i].bufnr
                if buf > 0 && buf != target_buf && bufloaded(buf)
                    let dstbuf = buf
                    break
                endif
                let i -= 1
            endwhile
            if dstbuf < 0
                if newbuf < 0 | let newbuf = bufadd('') | endif
                let &l:buflisted = 1
                let dstbuf = newbuf
            endif
            call win_gotoid(win)
            exec 'buffer' dstbuf
        endfor
        exec 'bdelete' . a:bang target_buf
        call win_gotoid(srcwin)
    endfor
endfunction

command! -nargs=* -range -addr=loaded_buffers -bang -complete=buffer
    \ Bdelete call s:Bdelete(<q-bang>, <line1>, <line2>, <f-args>)
nnoremap <C-Q> <Cmd>Bdelete<CR>

" }}}

" Capture command's output {{{

function! s:Run(system, cmd, input, ...) abort
    if a:system
        let out = systemlist(a:cmd, a:input)
        let reg = 's'
    else
        try
            let list = &l:list
            let &l:list = 0
            let out = execute(a:cmd)[1:]
        finally
            let &l:list = list
        endtry
        let reg = 'e'
    endif
    call setreg(reg, out)
    let mode = get(a:, 1, 1)
    if mode < 0
        redraw
        echo join(getreg(reg, 1, 1,), "\n")
        return
    endif
    if mode > 0
        exec get(a:, 2, '') 'new'
    endif
    setl bt=nofile bh=hide noswf nobl
    let b:run_system = a:system
    let b:run_cmd = a:cmd
    let b:run_input = a:input
    let b:run_title = (a:system ? '!' : ':') . a:cmd
    let [ma_, ro_] = [&l:ma, &l:ro]
    try
        setl ma noro
        silent exec 'Preserve %d_ | put' reg '| 1d_'
        if !a:system | %Sanitize | endif
    catch /:E353:/
    finally
        let [&l:ma, &l:ro] = [ma_, ro_]
        let v:statusmsg = b:run_title
    endtry
endfunction

command! -nargs=1 -count=1 -bang -complete=command Execute
    \ call utils#tryCatchCall('<SID>Run', 0, <q-args>, [], empty(<q-bang>) ? <count> > 0 : -1, <q-mods>)
nnoremap <Leader>xe :Execute<Space>
nnoremap <Leader>xE :Execute verb<Space>

command! -nargs=1 -count=1 -bang -complete=shellcmd System
    \ call utils#tryCatchCall('<SID>Run', 1, <q-args>, [], empty(<q-bang>) ? <count> > 0 : -1, <q-mods>)
command! -nargs=1 -bang -complete=shellcmd SystemRegister
    \ call utils#tryCatchCall('<SID>Run', 1, <q-args>, getreg(v:register, 1, 1), empty(<q-bang>) ? 1 : -1, <q-mods>)
command! -nargs=1 -range -bang -complete=shellcmd SystemRange
    \ call utils#tryCatchCall('<SID>Run', 1, <q-args>, getline(<line1>, <line2>), empty(<q-bang>) ? 1 : -1, <q-mods>)
nnoremap <Leader>xs :System<Space>
xnoremap <Leader>xs y:SystemRegister<Space>

function! s:Reload(bang) abort
    if exists('b:run_system')
        call s:Run(b:run_system, b:run_cmd, b:run_input, 0)
    else
        if &l:buftype =~# '^\(nofile\|quickfix\|terminal\)$'
            throw printf("\"%s\" buffer can't be reloaded", &l:buftype)
        endif
        silent exec 'Preserve edit' . a:bang
    endif
    let v:statusmsg = printf('[%s] %s', strftime('%H:%M:%S'), v:statusmsg)
    call utils#echo(utils#shortenCmdline(v:statusmsg))
endfunction

command! -bang -bar Reload call utils#tryCatchCall('<SID>Reload', <q-bang>)
nnoremap <Leader>rr <Cmd>Reload<CR>

function! s:ReloadT(bang, d) abort
    let d = str2nr(a:d)
    let d = d == 0 ? 1 : d
    try
        let v:statusmsg = ''
        while 1
            call s:Reload('')
            echon printf(' (every %ds)', d)
            if !empty(a:bang)
                normal! G
            endif
            exec 'sleep' d
        endwhile
    finally
        call utils#echo(utils#shortenCmdline(v:statusmsg))
    endtry
endfunction

command! -nargs=? -bang -bar ReloadT call utils#tryCatchCall('<SID>ReloadT', <q-bang>, <q-args>)
nnoremap <Leader>R <Cmd>ReloadT<CR>
nnoremap <Leader>F <Cmd>ReloadT!<CR>

" }}}

" Displaying options {{{

function! s:Option(opt) abort
    if exists('&' . a:opt)
        echo printf('&g:%s=%s', a:opt, eval('&g:' . a:opt))
        echo printf('&l:%s=%s', a:opt, eval('&l:' . a:opt))
    else
        call utils#echoError(printf('"%s" is not an option', a:opt))
    endif
endfunction

command! -nargs=1 -complete=option Option call s:Option(<q-args>)
nnoremap <Leader>oo :Option<Space>

function! s:BufOrWinOptions(getvar) abort
    for opt in sort(keys(a:getvar('&')))
        let g = a:getvar('&g:' . opt)
        let l = a:getvar('&l:' . opt)
        if type(g) == v:t_number
            echo printf('%-15s%10s%10s', opt, g, l)
        else
            echo printf("%-15s\n  =%s\n  =%s", opt, g, l)
        endif
    endfor
endfunction

function! s:BufAndWinOptions() abort
    echo 'Buffer options:'
    echo '----------------------------------------'
    call s:BufOrWinOptions(function('getbufvar', ['']))
    echon "\n"
    echo 'Window options:'
    echo '----------------------------------------'
    call s:BufOrWinOptions(function('getwinvar', [0]))
endfunction

command! -count=1 BufWinOptions <count>Execute call s:BufAndWinOptions()

" }}}

" Edit / Reload 'vimrc' {{{

nnoremap <silent> <Leader>rc :vsplit <C-R>=fnameescape(vimrc)<CR><CR>

try
function! s:VimrcReload() abort
    let winrestcmd = winrestcmd()

    new +setl\ bt=nofile\ bh=wipe\ noswf\ nobl
    exec 'source' fnameescape(g:vimrc)
    close

    "let winid = popup_create('VimrcReload', {'hidden': 1})
    "call win_execute(winid, 'source ' . fnameescape(g:vimrc))
    "call popup_close(winid)

    "let winids = map(getwininfo(), 'v:val.winid')
    "for opt in keys(getwinvar(0, '&'))
    "   let val = getwinvar(0, '&g:' . opt)
    "   for winid in winids
    "       call win_execute(winid, printf('let &g:%s = %s', opt, string(val)))
    "   endfor
    "endfor

    exec winrestcmd
    redraw
    call utils#echoWarn('vimrc reloaded')
endfunction
catch /:E127:/
endtry

command! -bar VimrcReload call s:VimrcReload()
nnoremap <Leader>so <Cmd>VimrcReload<CR>

" }}}

" Edit registers {{{

function! s:Register(regname, value) abort
    let regname = a:regname
    if empty(regname)
        let regname = '"'
        if &clipboard =~# 'unnamed' | let regname = '*' | endif
        if &clipboard =~# 'unnamedplus' | let regname = '+' | endif
    endif
    let value = substitute(a:value, '^=', '', '')
    call setreg(regname, value)
endfunction

command! -nargs=? -register Register call s:Register(<q-reg>, <q-args>)
nnoremap <Leader>re :Register <C-R>=v:register<CR> =<C-R>=getreg(v:register)<CR>

" }}}

" Formatting {{{

function! s:Format(...) range abort
    let ft = get(a:, 1, &ft)
    exec join([a:firstline . ',' . a:lastline, '!format', '-s', &sw, '-t', &tw, ft])
endfunction

command! -nargs=? -range -bar Format silent Preserve <line1>,<line2> call s:Format(<f-args>)
xnoremap <silent> <Leader>fo :Format<CR>
nnoremap <silent> <Leader>fo :%Format<CR>

xnoremap <silent> <Leader>px :Format xml<CR>
nnoremap <silent> <Leader>px :%Format xml<CR>

" }}}

" MoveToTab {{{

function! s:MoveToTab(next) abort
    if tabpagenr('$') == 1 && winnr('$') == 1 | return | endif
    let [tab, srcwin] = [tabpagenr(), win_getid()]
    if a:next ? tab < tabpagenr('$') : tab > 1
        exec a:next ? 'tabnext' : 'tabprev'
        botright vsplit
    else
        if winnr('$') == 1 | return | endif
        exec a:next ? 'tabnew' : '0tabnew'
    endif
    exec 'buffer' winbufnr(srcwin)
    let dstwin = win_getid()
    call win_gotoid(srcwin)
    close!
    call win_gotoid(dstwin)
endfunction

command! -bar MoveToNextTab call s:MoveToTab(1)
command! -bar MoveToPrevTab call s:MoveToTab(0)
nnoremap <C-W><M-l> <Cmd>MoveToNextTab<CR>
nnoremap <C-W><M-h> <Cmd>MoveToPrevTab<CR>

" }}}

" Next/PrevClosedFold <https://stackoverflow.com/questions/9403098/is-it-possible-to-jump-to-closed-folds-in-vim> {{{

function! s:MoveToClosedFold(next) abort
    let cmd = 'normal! z' . (a:next ? 'j' : 'k')
    let view = winsaveview()
    let [lnum0, lnum, isopen] = [0, view.lnum, 1]
    while lnum != lnum0 && isopen
        exec cmd
        let [lnum0, lnum] = [lnum, line('.')]
        let isopen = foldclosed(lnum) < 0
    endwhile
    if isopen | call winrestview(view) | endif
endfunction

command! -bar NextClosedFold call s:MoveToClosedFold(1)
command! -bar PrevClosedFold call s:MoveToClosedFold(0)
nnoremap <Leader>zj <Cmd>NextClosedFold<CR>
nnoremap <Leader>zk <Cmd>PrevClosedFold<CR>

" }}}

" Preserve cursor / window position, last search pattern, and the others {{{

function! s:Preserve(cmd) abort
    let view = winsaveview()
    exec 'keepa keepj keepm keepp' a:cmd
    call winrestview(view)
endfunction

command! -nargs=1 Preserve call s:Preserve(<q-args>)

" }}}

" Starts diff of current buffer with another file {{{

function! s:DiffTo(file) abort
    let file = fnamemodify(a:file, ':p')
    if isdirectory(file)
        call utils#echoError(printf('"%s" is a directory', fnamemodify(file, ':h')))
        return
    endif
    if !filereadable(file)
        call utils#echoError(printf('"%s" is not readable', file))
        return
    endif
    vnew
    exec 'read ++edit' fnameescape(file) | 0d_
    exec 'setl bt=nofile bh=wipe noswf nobl noma ft=' . getbufvar('#', '&ft')
    exec 'silent file DiffTo:\ ' . fnameescape(fnamemodify(file, ':~'))
    diffthis
    wincmd p
    diffthis
endfunction

command! -nargs=1 -complete=file DiffTo call s:DiffTo(<q-args>)
nnoremap <Leader>df :DiffTo <C-R>=expand('%')<CR>

" }}}

" Toggles translation of ASCII meta escape prefix encoding to 8 bit meta encoding {{{

function! s:MetaLess(cmd) abort
    exec a:cmd
endfunction

if !has('nvim')

function! s:MetaSetup(enable) abort
    for c in map(range(1, 126), 'nr2char(v:val)')
        if stridx('|"', c) >= 0
            let c = '\' . c
        elseif stridx("\x09\x0a\x16 >[]", c) >= 0
            continue
        endif
        let kc = printf('<M-%s>', c)
        exec printf('set %s=%s', kc, a:enable ? "\e" . c : '')
        if empty(maparg(kc, 'i')) | exec printf('inoremap %s <Nop>', kc) | endif
        if empty(maparg(kc, 'c')) | exec printf('cnoremap %s <Nop>', kc) | endif
    endfor
    let g:meta_enabled = a:enable
    if !has('vim_starting')
        call utils#echoWarn('meta ' . (g:meta_enabled ? 'on' : 'off'))
    endif
endfunction

function! s:MetaLess(cmd) abort
    if g:meta_enabled
        silent call s:MetaSetup(0)
        exec a:cmd
        silent call s:MetaSetup(1)
    else
        exec a:cmd
    endif
endfunction

command! -bar MetaToggle call s:MetaSetup(!get(g:, 'meta_enabled', 0))
nnoremap <Leader>mm <Cmd>MetaToggle<CR>
silent call s:MetaSetup(1)

endif

" }}}

" Walks through list of colorschemes (q/C-C=quit, k=prev, default=next) {{{

function! s:Themes() abort
    let themes = ['luciusblack', 'hybrid', 'bclear']
    let [i, lasti] = [get(s:, 'themes_last_index'), len(themes)-1]
    while 1
        exec 'colorscheme' themes[i]
        redraw | echo themes[i]
        let c = getchar()
        if c == 3 || c == 113
            break
        elseif c == 107
            let i = i > 0 ? i-1 : lasti
        else
            let i = i < lasti ? i+1 : 0
        endif
    endwhile
    let s:themes_last_index = i
    redraw | echo
endfunction

command! Themes call s:Themes()
nnoremap <Leader>th <Cmd>Themes<CR>

" }}}

" Write with elevated privileges {{{

function! s:Write(...) abort
    let filename = get(a:, 1, expand('%'))
    exec 'silent write !sudo tee >/dev/null' shellescape(filename, 1)
    edit!
endfunction

command! -nargs=? -bar W call s:Write(<f-args>)

" }}}

" Zoom / Restore window {{{

function! s:ZoomToggle() abort
    if get(t:, 'zoomed')
        exec t:zoom_winrestcmd
        let t:zoomed = 0
    else
        let t:zoom_winrestcmd = winrestcmd()
        resize
        vert resize
        let t:zoomed = 1
    endif
endfunction

command! -bar ZoomToggle call s:ZoomToggle()
nnoremap <M-m> <Cmd>ZoomToggle<CR>
nnoremap <M-z> <Cmd>ZoomToggle<CR>

" }}}

" ----------------------------------------

command! -nargs=? -range Split
    \ call utils#tryCatch(
    \     printf('Preserve <line1>,<line2>s/%s/\r/ge',
    \         !empty(<q-args>) ? escape(<q-args>, '/') : '\s\+'
    \     )
    \ )

command! -nargs=? -range Join
    \ call utils#tryCatch(
    \     printf('Preserve <line1>,%ds/\n/%s/ge',
    \         <line2> > <line1> ? <line2>-1 : <line2>,
    \         !empty(<q-args>) ? escape(<q-args>, '/&') : ' '
    \     )
    \ )

command! -count=1 PackPath exec '<count>Execute set pp' | exec 'normal! df=' | Split,
command! -count=1 RuntimePath exec '<count>Execute set rtp' | exec 'normal! df=' | Split,
command! -count=1 ScriptNames <count>Execute scriptnames

command! DelDirs Preserve g/\/$/d

command! -range -bar Sanitize silent Preserve <line1>,<line2> s/\s\+$//e
xnoremap <silent> <Leader>pp :Sanitize<CR>
nnoremap <silent> <Leader>pp :%Sanitize<CR>

nnoremap <Leader>== <Cmd>Preserve normal! gg=G<CR>
nnoremap <Leader>gq <Cmd>Preserve normal! gggqG<CR>

xnoremap <silent> <Leader>uu :SystemRange! urls -o<CR>
nnoremap <silent> <Leader>uu :.SystemRange! urls -o<CR>
nnoremap <silent> <Leader>uU :%SystemRange! urls -o<CR>

xnoremap <silent> <Leader>uy :SystemRange! urls -y<CR>
nnoremap <silent> <Leader>uy :.SystemRange! urls -y<CR>
nnoremap <silent> <Leader>uY :%SystemRange! urls -y<CR>

nnoremap <Leader>gg :vert System git show HEAD:./

" ----------------------------------------

let loaded_2html_plugin = 1
let loaded_getscriptPlugin = 1
let loaded_logiPat = 1
let loaded_netrwPlugin = 1
let loaded_rrhelper = 1
let loaded_spellfile_plugin = 1
let loaded_vimballPlugin = 1

if has('nvim')
    let loaded_man = 1
    let loaded_remote_plugins = 1
    let loaded_tutor_mode_plugin = 1
endif

packadd! ansiesc:drchip
packadd! cfilter
packadd! colorschemes
packadd! matchit

filetype plugin indent on
if !exists('g:syntax_on')
    syntax enable
endif

ColorsReset

augroup vimrc_base
    autocmd!

    autocmd BufEnter,BufWinEnter * match none
    autocmd FileChangedRO * setl noro
    autocmd QuickFixCmdPost [^l]* cwindow

    autocmd CmdwinEnter *
        \  call utils#bufSpecial()
        \| noremap <buffer> <C-J> <C-C><C-E>

    autocmd BufReadPost *
        \  if line("'\"") >= 1 && line("'\"") <= line('$') && &ft !~# 'commit'
        \|     exec 'normal! g`"'
        \| endif

    function! s:TerminalSetup() abort
        call utils#bufSpecial()
        setl list
        let &l:stl = printf('%%{%%%sTerminalStatusline()%%}', expand('<SID>'))
    endfunction

    function! s:TerminalStatusline() abort
        let stl = '%n'
        let bin = matchstr(expand('%'), '\C^term://\%(.\{-}//\%(\d\+:\)\?\)\?\zs.*')
        if empty(bin)
            let stl .= ' %<%f'
        else
            if bin == exepath(&shell) | let bin = &shell | endif
            let stl .= printf(' !%s', bin)
        endif
        if exists('b:term_title') && match(b:term_title, '\C^term://') < 0
            let stl .= printf(' [%s]', b:term_title)
        endif
        if mode() == 'n'
            let stl .= '%= %6(%l:%v%) %P'
        endif
        return stl
    endfunction

    if has('nvim')
        autocmd TermOpen,TermLeave * call s:TerminalSetup()
        autocmd TermOpen * startinsert
        autocmd TermEnter * setl nolist
    else
        autocmd TerminalWinOpen * call s:TerminalSetup()
        autocmd TermChanged * silent call s:MetaSetup(meta_enabled)
    endif

    autocmd BufWritePost conky.conf !killall -USR1 conky
    autocmd BufWritePost ~/.Xresources !xrdb -screen -load ~/.Xresources

    autocmd FileType diff call utils#bufSpecial()
    autocmd FileType mail call utils#bufSpecial() | setl tw=72
    autocmd FileType make setl ts=4 sw=4 noet
    autocmd FileType man call utils#bufSpecial() | setl noma ts=8
    autocmd FileType rst setl ts=8 sw=3 fdm=manual foldtext&
    autocmd FileType tar call utils#bufSpecial()
    autocmd FileType yaml setl ts=2 sw=2
    autocmd FileType zip call utils#bufSpecial()
    autocmd FileType {c,cpp}{,.*} let &l:path = '.,,**,/usr/include'
augroup END

" ----------------------------------------

hi link Boolean                         Constant
hi link Character                       Constant
hi link Conditional                     Statement
hi link Debug                           Special
hi link Define                          PreProc
hi link Delimiter                       Special
hi link Exception                       Statement
hi link Float                           Number
hi link Function                        Identifier
hi link HelpCommand                     Statement
hi link HelpExample                     Statement
hi link Include                         PreProc
hi link Keyword                         Statement
hi link Label                           Statement
hi link Macro                           PreProc
hi link Number                          Constant
hi link Operator                        Statement
hi link PreCondit                       PreProc
hi link Repeat                          Statement
hi link SpecialChar                     Special
hi link SpecialComment                  Special
hi link StorageClass                    Type
hi link String                          Constant
hi link Structure                       Type
hi link Tag                             Special
hi link Typedef                         Type
hi link asciidocQuotedEmphasized        PreProc
hi link diffBDiffer                     Statement
hi link diffCommon                      Statement
hi link diffDiffer                      Statement
hi link diffIdentical                   Statement
hi link diffIndexLine                   Type
hi link diffIsA                         Statement
hi link diffNoEOL                       Statement
hi link diffOnly                        Statement
hi link diffRemoved                     Constant
hi link htmlBold                        Normal
hi link htmlEndTag                      htmlTagName
hi link htmlItalic                      Normal
hi link htmlLink                        Function
hi link htmlSpecialTagName              htmlTagName
hi link htmlTag                         htmlTagName
hi link markdownItalic                  PreProc
hi link xmlEndTag                       Statement
hi link xmlTag                          Statement
hi link xmlTagName                      Statement
