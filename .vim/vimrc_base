" vim: ft=vim fdm=marker

let vimrc = get(g:, 'vimrc', expand('<sfile>:p'))
let $MYVIMRC = vimrc


" Important
" ----------------------------------------

set nocompatible
set pastetoggle=<F6>

set rtp =
    \ rtp+=~/.vim
    \ rtp+=/usr/share/vim/vimfiles
    \ rtp+=$VIMRUNTIME
    \ rtp+=~/.vim/after

if has('nvim')
    call utils#rtpPrepend('~/.config/nvim')
endif

let bin = has('nvim') ? 'nvim' : 'vim'
let $VIMDIR = $HOME . '/.local/share/' . bin

if isdirectory($BASEDIR)
    call utils#rtpPrepend($BASEDIR . '/.vim')
    if has('nvim')
        call utils#rtpPrepend($BASEDIR . '/.nvim')
    endif
    let $VIMDIR = $BASEDIR . '/.' . bin
endif

let &pp = &rtp


" Moving Around, Searching and Patterns
" ----------------------------------------

set ignorecase
set incsearch
set paragraphs=
set path=.,,**
set sections=
set smartcase
set whichwrap=b,s,<,>,[,]

let mapleader = ','
let maplocalleader = ';'

noremap <M-,> ,
noremap <M-;> ;

noremap - ^

noremap <M-j> 5j
noremap <M-k> 5k

noremap <M-C-L> 5l
noremap <M-C-H> 5h
nmap <M-BS> <M-C-H>

noremap <C-E> 5<C-E>
noremap <C-Y> 5<C-Y>

noremap zl 5zl
noremap zh 5zh

nnoremap J <Cmd>exec 'move +' . v:count1<CR>
nnoremap K <Cmd>exec 'move -1-' . v:count1<CR>

xnoremap <silent> J :move '>+<C-R>=v:count1<CR><CR>gv
xnoremap <silent> K :move '<-1-<C-R>=v:count1<CR><CR>gv

nnoremap * <Cmd>let @/ = '\V\<' . escape(expand('<cword>'), '\/') . '\>' \| set hls<CR>
nnoremap g* <Cmd>let @/ = '\V' . escape(expand('<cword>'), '\/') \| set hls<CR>
nnoremap # <Cmd>let @/ = '\V\S\@<!' . escape(expand('<cWORD>'), '\/') . '\S\@!' \| set hls<CR>
nnoremap g# <Cmd>let @/ = '\V' . escape(expand('<cWORD>'), '\/') \| set hls<CR>
xnoremap g/ y<Cmd>let @/ = '\V' . escape(@", '\/') \| call histadd('search', @/) \| set hls<CR>


" Tags
" ----------------------------------------

set tags-=./tags tags-=./tags; tags^=./tags;

nnoremap <F12> <Cmd>call system('mktags') \| call utils#echoWarn('mktags finished')<CR>
nnoremap <Leader>lt :ltag /


" Displaying Text
" ----------------------------------------

set display=lastline
set fillchars=
set list
set listchars=eol:¬,tab:>-,trail:-,extends:>,precedes:<,nbsp:+,conceal:_
set nowrap
set scrolloff=2
set sidescroll=10
set sidescrolloff=10

nnoremap <Leader>L :setl <C-R>=&list ? 'nolist' : 'list'<CR><CR>
nnoremap <Leader>U :setl display<C-R>=&display =~# 'uhex' ? '-' : '+'<CR>=uhex<CR>
nnoremap <Leader>W :setl <C-R>=&wrap ? 'nowrap' : 'wrap'<CR><CR>


" Syntax, Highlighting and Spelling
" ----------------------------------------

set colorcolumn=80
set hlsearch
set spelllang=en_us
set spelloptions=camel
set synmaxcol=200

let c_comment_strings = 1
let load_doxygen_syntax = 1
let python_highlight_all = 1

nnoremap <Space> <Cmd>diffup! \| nohls \| echo<CR>
nnoremap <Leader>ft <Cmd>filetype detect \| syn sync fromstart<CR>

nnoremap <Leader>cuc :setl <C-R>=&cuc ? 'nocuc' : 'cuc'<CR><CR>
nnoremap <Leader>cul :setl <C-R>=&cul ? 'nocul' : 'cul'<CR><CR>
nnoremap <Leader>cux :setl <C-R>=&cuc && &cul ? 'nocuc nocul' : 'cuc cul'<CR><CR>
nnoremap <Leader>sp :setl <C-R>=&spell ? 'nospell' : 'spell'<CR><CR>

function! s:ccToggle() abort
    if !empty(&l:cc)
        let w:cc = &l:cc
        let &l:cc = ''
    else
        let &l:cc = get(w:, 'cc', &g:cc)
    endif
    call utils#echo(printf(':setl cc=%s', &l:cc))
endfunction

function! s:ccToggleColumn(col) abort
    if index(split(&l:cc, ','), string(a:col)) < 0
        exec 'setl cc+=' . a:col
    else
        exec 'setl cc-=' . a:col
    endif
    call utils#echo(printf(':setl cc=%s', &l:cc))
endfunction

function! s:ccCycle() abort
    if !empty(&l:cc) && &l:cc != &g:cc
        let w:cc_cycle = &l:cc
        let &l:cc = &g:cc
    else
        let &l:cc = get(w:, 'cc_cycle', &g:cc)
    endif
    call utils#echo(printf(':setl cc=%s', &l:cc))
endfunction

nnoremap <Leader>col <Cmd>call <SID>ccToggle()<CR>
nnoremap <Leader>coL <Cmd>call <SID>ccToggleColumn(virtcol('.'))<CR>
nnoremap <Leader>co< <Cmd>call <SID>ccCycle()<CR>

function! s:ColorsReset() abort
    if has('gui_running')
        colorscheme bclear
    else
        if &t_Co < 256
            colorscheme desert
        else
            colorscheme luciusblack
        endif
    endif
endfunction

command! -bar ColorsReset call s:ColorsReset()
command! -bar Hitest call s:MetaLess('silent runtime syntax/hitest.vim')


" Multiple Windows
" ----------------------------------------

set hidden
set laststatus=2
set splitbelow
set splitright
set winheight=5

let stlTail = '%6(%l:%v%) %P'
let stlTail .= "%( %{%
    \ argc() > 0
    \ ? (arglistid() == 0 ? '' : 'L')
        \ . (argv(argidx()) == bufname() ? '*' : '-')
        \ . (argidx() + 1) . '/' . argc()
        \ : ''
    \ %}%)"

let &g:stl = '%n %<%f'
let &g:stl .= '%( [%M%W%R]%)'
let &g:stl .= '%( %y%)'
let &g:stl .= "%( [%{&l:fenc != 'utf-8' ? &l:fenc : ''}]%)"
let &g:stl .= "%( [%{&l:ff != 'unix' ? &l:ff : ''}]%)"
let &g:stl .= "%( %{get(b:, 'run_title', '')}%)"
let &g:stl .= "%( %{get(w:, 'quickfix_title', '')}%)"
let &g:stl .= '%=' . stlTail

nnoremap <C-J> <C-W>j
nnoremap <C-K> <C-W>k
nnoremap <C-L> <C-W>l
nnoremap <C-H> <C-W>h
nmap <BS> <C-H>

nnoremap s<C-J> <Cmd>below split<CR>
nnoremap s<C-K> <Cmd>above split<CR>
nnoremap s<C-L> <Cmd>rightb vsplit<CR>
nnoremap s<C-H> <Cmd>lefta vsplit<CR>
nmap s<BS> s<C-H>

nnoremap c<C-J> <Cmd>below new<CR>
nnoremap c<C-K> <Cmd>above new<CR>
nnoremap c<C-L> <Cmd>rightb vnew<CR>
nnoremap c<C-H> <Cmd>lefta vnew<CR>
nmap c<BS> c<C-H>

nnoremap <C-W>N <Cmd>vnew<CR>
nnoremap <C-W><C-N> <Cmd>vnew<CR>

nnoremap d<C-J> <C-W>j<C-W>c<C-W>p
nnoremap d<C-K> <C-W>k<C-W>c<C-W>p
nnoremap d<C-L> <C-W>l<C-W>c<C-W>p
nnoremap d<C-H> <C-W>h<C-W>c<C-W>p
nmap d<BS> d<C-H>

nnoremap <C-_> <C-W>_
nnoremap g<C-J> <C-W>j<C-W>_
nnoremap g<C-K> <C-W>k<C-W>_

nnoremap _ <Cmd>resize -5<CR>
nnoremap + <Cmd>resize +5<CR>
nnoremap <M--> <Cmd>vert resize -5<CR>
nnoremap <M-=> <Cmd>vert resize +5<CR>


" Multiple Tab Pages
" ----------------------------------------

set tabpagemax=50

let &g:tabline = '%!' . expand('<SID>') . 'TabLine()'

function! s:TabLine() abort
    let [cur, last] = [tabpagenr(), tabpagenr('$')]
    let [beg, end] = [1, last]
    let [line, llen, curline] = ['', 0, 0]
    for i in range(beg, end)
        let winnr = tabpagewinnr(i)
        let winid = win_getid(winnr, i)
        let buf = tabpagebuflist(i)[winnr - 1]
        let bt = getbufvar(buf, '&bt')
        let prefer_bufname = 1
        if empty(bt)
            let name = '[No Name]'
        elseif bt == 'quickfix'
            let loclist = get(getwininfo(winid)[0], 'loclist', 0)
            let name = loclist ? '[LocList]' : '[QfList]'
            let prefer_bufname = 0
        elseif bt == 'terminal'
            let name = '[Term]'
            let prefer_bufname = 0
        elseif bt == 'prompt'
            let name = '[Prompt]'
        elseif bt == 'popup'
            let name = '[Popup]'
        else
            let name = '[Scratch]'
        endif
        let bufname = bufname(buf)
        if !empty(bufname) && prefer_bufname
            if empty(bt) || bt == 'nowrite'
                let name = fnamemodify(bufname, ':~:.')
                if len(name) > 20
                    let name = substitute(name, '\v/\zs(.).{-}\ze/', '\1', 'g')
                endif
            elseif bt == 'help'
                let name = fnamemodify(bufname, ':t')
            else
                let name = bufname
            endif
        endif
        if getbufvar(buf, 'ft_tabline', 0)
            let name = printf('·%s·', getbufvar(buf, '&ft'))
        endif
        let len = len(name) + 2
        if llen + len > &co
                \ - (beg > 1) * 2
                \ - (i < last) * 3
                \ - len(i) - len(last) - 1
                \ - 4
            if curline | break | endif
            let beg = i
            let [line, llen] = ['', 0]
        endif
        let end = i
        let llen += len
        let line .= (i == cur) ? '%#TabLineSel#' : '%#TabLine#'
        let line .= printf(' %%%dT%s%%T ', i, substitute(name, '%', '%%', 'g'))
        if !curline | let curline = i == cur | endif
    endfor
    let tl = '%#TabLine#'
    if beg > 1 | let tl .= '<<' | endif
    let tl .= line . '%#TabLine#'
    if end < last | let tl .= '>> ' | endif
    let tl .= printf('%%=%d/%d', cur, last)
    let tl .= ' %999X[×]%X'
    return tl
endfunction

nnoremap <M-1> 1gt
nnoremap <M-2> 2gt
nnoremap <M-3> 3gt
nnoremap <M-4> 4gt
nnoremap <M-5> 5gt
nnoremap <M-6> 6gt
nnoremap <M-7> 7gt
nnoremap <M-8> 8gt
nnoremap <M-9> 9gt

nnoremap <M-a> g<Tab>
nnoremap <M-0> <Cmd>tabfirst<CR>
nnoremap <M-^> <Cmd>tabfirst<CR>
nnoremap <M-$> <Cmd>tablast<CR>
nnoremap <M-(> <Cmd>tabfirst<CR>
nnoremap <M-)> <Cmd>tablast<CR>

nnoremap <M-h> gT
nnoremap <M-l> gt
nnoremap <M-H> <Cmd>silent! tabmove -1<CR>
nnoremap <M-L> <Cmd>silent! tabmove +1<CR>

nnoremap <M-n> <Cmd>tabnew<CR>
nnoremap <M-N> <Cmd>tab split<CR>

function! s:QuitTab(bang) abort
    try
        exec 'tabclose' . a:bang
    catch /:E784:/
        silent exec empty(a:bang) ? 'qall' : 'cquit'
    endtry
endfunction

command! -bang -bar QuitTab call utils#tryCatchCall('<SID>QuitTab', <q-bang>)
nnoremap QQ <Cmd>QuitTab<CR>
nnoremap QA <Cmd>QuitTab!<CR>


" Terminal
" ----------------------------------------

if !has('nvim')
    set termwinkey=<C-\\>
endif

tnoremap <C-\> <C-\><C-N>


" Using the Mouse
" ----------------------------------------

set mouse=

nnoremap <Leader>M :set <C-R>=!empty(&mouse) ? 'mouse=' : 'mouse=a'<CR><CR>


" TUI/GUI
" ----------------------------------------

set guicursor+=a:blinkon0
set guifont=Terminus\ 16px
set guioptions=ce
set title

set titlestring=
    \%{v:progname}:
    \\ %n\ %<%f
    \%(\ [%M%W%R]%)
    \%(\ %y%)
    \%(\ [%{&l:fenc!='utf-8'?&l:fenc:''}]%)
    \%(\ [%{&l:ff!='unix'?&l:ff:''}]%)
    \%(\ %{get(b:,'run_title','')}%)
    \%(\ %{get(w:,'quickfix_title','')}%)

if !has('nvim')
    set nottybuiltin
    set ttyfast
    let &t_ut = ''
    let &t_EI = "\e[2 q"
    let &t_SR = "\e[4 q"
    let &t_SI = "\e[6 q"
    let &t_BE = "\e[?2004h"
    let &t_BD = "\e[?2004l"
    let &t_PS = "\e[200~"
    let &t_PE = "\e[201~"
endif

map! <S-Insert> <MiddleMouse>


" Messages and Info
" ----------------------------------------

set belloff=all
set ruler
set shortmess=aoOtTWIF
set showcmd
set showmode


" Selecting Text
" ----------------------------------------

set clipboard=unnamed

if has('nvim')
    let clipboard = #{
    \     name: 'xsel',
    \     copy: {
    \         '+': ['xsel', '--nodetach', '-i', '-b'],
    \         '*': ['xsel', '--nodetach', '-i', '-p'],
    \     },
    \     paste: {
    \         '+': ['xsel', '-o', '-b'],
    \         '*': ['xsel', '-o', '-p'],
    \     },
    \     cache_enabled: 1,
    \ }
endif

nnoremap Y y$
nnoremap <expr> gp printf('`[%s`]', getregtype()[0])


" Editing Text
" ----------------------------------------

set backspace=indent,eol,start
set complete-=i
set completeopt=menuone,longest
set formatoptions=tcroqln21j
set matchpairs+=<:>
set nojoinspaces
set nrformats=alpha,hex,bin,unsigned
set showmatch
set textwidth=80
set tildeop
set undofile

let &undodir = $VIMDIR . '/undo//'
call utils#mkdir(&undodir)

noremap cw dwi
noremap cW dWi

noremap <Leader><C-J> J

inoremap <C-B> <Home>
inoremap <expr> <C-E> pumvisible() ? "\<C-E>" : "\<End>"
inoremap <M-h> <Left>
inoremap <M-l> <Right>
inoremap <M-b> <Cmd>call utils#moveWord(0)<CR>
inoremap <M-f> <Cmd>call utils#moveWord(1, 1)<CR>
inoremap <M-w> <Cmd>call utils#moveWord(1)<CR>

inoremap <C-U> <C-G>u<C-U>
inoremap <C-K> <C-G>u<C-\><C-O>d$
inoremap <C-W> <C-G>u<C-W>
inoremap <M-d> <C-G>u<C-\><C-O>d<Cmd>call utils#moveWord(1, 1)<CR>
inoremap <M-x> <Delete>

inoremap <M-j> <C-G>j
inoremap <M-k> <C-G>k

inoremap <C-_> <C-K>
inoremap <M-e> <C-E>
inoremap <M-y> <C-Y>

inoremap <expr> <C-G><C-F> expand('%:t')
inoremap <expr> <C-G><C-P> expand('%:p')
inoremap <expr> <C-G><C-D> strftime('%c')
imap <C-G>f <C-G><C-F>
imap <C-G>p <C-G><C-P>
imap <C-G>d <C-G><C-D>

inoremap <C-F> <C-X><C-F>
inoremap <expr> <C-L> pumvisible() ? "\<C-L>" : "\<C-X>\<C-L>"


" Tabs and Indenting
" ----------------------------------------

set autoindent
set copyindent
set expandtab
set preserveindent
set shiftwidth=0
set smartindent
set smarttab
set softtabstop=-1
set tabstop=4


" Folding
" ----------------------------------------

set foldopen-=block

nnoremap <Leader>ff :setl fdm=manual \| normal! zE<CR>
nnoremap <Leader>fi :setl fdm=indent fdn=2 \| normal! zM<CR>
nnoremap <Leader>fm :setl fdm=marker \| normal! zM<CR>
nnoremap <Leader>fs :setl fdm=syntax \| normal! zM<CR>


" Diff Mode
" ----------------------------------------

set diffopt+=algorithm:patience


" Mapping
" ----------------------------------------

set ttimeout
set ttimeoutlen=10


" Reading and Writing Files
" ----------------------------------------

set autoread
set backup
set fileformats+=mac
set modeline

let &backupdir = $VIMDIR . '/backup//'
call utils#mkdir(&backupdir)


" The Swap File
" ----------------------------------------

set swapfile
set updatetime=300

let &directory = $VIMDIR . '/swap//'
call utils#mkdir(&directory)

function! s:Swap() abort
    let this = swapname('%')
    if empty(this) | return | endif
    let base = fnamemodify(this, ':r')
    for f in glob(base . '.*', 1, 1)
        if f == this | continue | endif
        let i = swapinfo(f)
        echo 'swap: ' . fnamemodify(f, ':~')
        echo printf('created by: %s %s@%s (pid: %s)', i.version, i.user, i.host, i.pid)
        echo 'mtime: ' . strftime('%c', i.mtime)
        echo 'dirty: ' . i.dirty
        echo ''
        if confirm('Delete?', "&Yes\n&No", 2) == 1 | call delete(f) | endif
    endfor
endfunction

command! -bar Swap call s:Swap()


" Command Line Editing
" ----------------------------------------

set history=1000
set suffixes=.bak,.swp,~
set wildcharm=<C-Z>
set wildmenu
set wildmode=lastused:longest:full,full

cnoremap <Left> <Space><BS><Left>
cnoremap <Right> <Space><BS><Right>
cnoremap <expr> <C-N> wildmenumode() ? "<C-N>" : "<Down>"
cnoremap <expr> <C-P> wildmenumode() ? "<C-P>" : "<Up>"

cnoremap <expr> <Tab> getcmdtype() =~ "[/?]" ? "<C-G>" : "<C-Z>"
cnoremap <expr> <S-Tab> getcmdtype() =~ "[/?]" ? "<C-T>" : (wildmenumode() ? "<S-Tab>" : "<C-Z>")
cmap <M-n> <Tab>
cmap <M-p> <S-Tab>

" <C-B> <Home>
" <C-E> <End>
cmap <M-h> <Left>
cmap <M-l> <Right>
cnoremap <M-b> <C-\>e utils#cmdlineMoveWord(0)<CR>
cnoremap <M-f> <C-\>e utils#cmdlineMoveWord(1, 1)<CR>
cnoremap <M-w> <C-\>e utils#cmdlineMoveWord(1)<CR>

" <C-U> - backward kill line
cnoremap <C-K> <C-\>e strpart(getcmdline(), 0, getcmdpos() - 1)<CR>
cnoremap <C-W> <C-\>e utils#cmdlineKillWord(0)<CR>
cnoremap <M-d> <C-\>e utils#cmdlineKillWord(1, 1)<CR>
cnoremap <M-x> <Delete>

cnoremap <C-_> <C-K>
cnoremap <C-O> <S-Tab>
cnoremap <expr> %% fnamemodify(expand('%:h'), ':~') . '/'
cnoremap <expr> %<Space> '%'


" Executing External Commands
" ----------------------------------------

set shell=bashx
set shellredir=&>%s

noremap <Leader><C-K> K


" Running 'make' and Jumping To Errors
" ----------------------------------------

set grepformat=%f:%l:%c:%m,%f:%l:%m
set grepprg=internal
set shellpipe=\|&\ tee

nnoremap <F9> :make!<CR>

nnoremap <Leader>cl <Cmd>copen<CR>
nnoremap <Leader>ll <Cmd>lopen<CR>

nnoremap <Leader>J <Cmd>cnext<CR>
nnoremap <Leader>K <Cmd>cprev<CR>

function! s:LocOrQfCmd(cmd) abort
    try
        echo
        exec 'l' . a:cmd
    catch /:E\(42\|776\):/
        exec 'c' . a:cmd
    endtry
endfunction

nnoremap <Leader>j <Cmd>call utils#tryCatchCall('<SID>LocOrQfCmd', 'next')<CR>
nnoremap <Leader>k <Cmd>call utils#tryCatchCall('<SID>LocOrQfCmd', 'prev')<CR>

function! s:QfText(item2line) abort
    function! s:QfText_(ctx) closure abort
        let items = a:ctx.quickfix
            \ ? getqflist(#{id: a:ctx.id, items: 0}).items
            \ : getloclist(a:ctx.winid, #{id: a:ctx.id, items: 0}).items
        let lines = []
        for idx in range(a:ctx.start_idx - 1, a:ctx.end_idx - 1)
            call add(lines, a:item2line(items[idx]))
        endfor
        return lines
    endfunction
    return function('s:QfText_')
endfunction

function! s:QfFiles(loclist, action, files_func, title) abort
    let SetList = a:loclist ? function('setloclist', [0]) : function('setqflist')
    call SetList([], a:action, #{
        \ nr: a:action == ' ' ? '$' : 0,
        \ efm: '%f',
        \ lines: a:files_func(),
        \ title: a:title,
        \ quickfixtextfunc: s:QfText({i -> fnamemodify(bufname(i.bufnr), ':p:~')}),
        \ context: #{reload_func: function('s:QfFiles', [a:loclist, 'r', a:files_func, a:title])},
        \ })
    exec a:loclist ? 'lwindow' : 'cwindow'
endfunction

command! -bang -bar Cargs call s:QfFiles(0, empty(<q-bang>) ? ' ' : 'r', {-> argv(-1, -1)}, ':Cargs')
command! -bang -bar Largs call s:QfFiles(1, empty(<q-bang>) ? ' ' : 'r', {-> argv()}, ':Largs')
command! -bang -bar OldFiles call s:QfFiles(0, empty(<q-bang>) ? ' ' : 'r', {-> v:oldfiles}, ':OldFiles')

function! s:QfSystem(loclist, action, cmd, title = '!' . a:cmd) abort
    let SetList = a:loclist ? function('setloclist', [0]) : function('setqflist')
    call SetList([], a:action, #{
        \ nr: a:action == ' ' ? '$' : 0,
        \ lines: systemlist(a:cmd),
        \ title: a:title,
        \ quickfixtextfunc: 0,
        \ context: #{reload_func: function('s:QfSystem', [a:loclist, 'r', a:cmd, a:title])},
        \ })
    exec a:loclist ? 'lwindow' : 'cwindow'
endfunction

function! s:QfGrep(loclist, action, args) abort
    call s:QfSystem(a:loclist, a:action,
                    \ 'grep -rnH --exclude-dir=.git ' . a:args,
                    \ printf(':%sgrep %s', a:loclist ? 'L' : 'C', a:args))
endfunction

command! -nargs=* -bang Cgrep call s:QfGrep(0, empty(<q-bang>) ? ' ' : 'r', <q-args>)
command! -nargs=* CgrepAdd call s:QfGrep(0, 'a', <q-args>)
command! -nargs=* -bang Lgrep call s:QfGrep(1, empty(<q-bang>) ? ' ' : 'r', <q-args>)
command! -nargs=* LgrepAdd call s:QfGrep(1, 'a', <q-args>)

function! s:QfRg(loclist, add, args) abort
    call s:QfSystem(a:loclist, a:action,
                    \ 'rg --vimgrep --no-ignore ' . a:args,
                    \ printf(':%srg %s', a:loclist ? 'L' : 'C', a:args))
endfunction

command! -nargs=* -bang Crg call s:QfRg(0, empty(<q-bang>) ? ' ' : 'r', <q-args>)
command! -nargs=* CrgAdd call s:QfRg(0, 'a', <q-args>)
command! -nargs=* -bang Lrg call s:QfRg(1, empty(<q-bang>) ? ' ' : 'r', <q-args>)
command! -nargs=* LrgAdd call s:QfRg(1, 'a', <q-args>)

function! s:QfAg(loclist, add, args) abort
    call s:QfSystem(a:loclist, a:action,
                    \ 'ag --vimgrep ' . a:args,
                    \ printf(':%srg %s', a:loclist ? 'L' : 'C', a:args))
endfunction

command! -nargs=* -bang Cag call s:QfAg(0, empty(<q-bang>) ? ' ' : 'r', <q-args>)
command! -nargs=* CagAdd call s:QfAg(0, 'a', <q-args>)
command! -nargs=* -bang Lag call s:QfAg(1, empty(<q-bang>) ? ' ' : 'r', <q-args>)
command! -nargs=* LagAdd call s:QfAg(1, 'a', <q-args>)


" Language Specific
" ----------------------------------------

silent! set keymap=slovak

set iminsert=0
set imsearch=-1


" Various
" ----------------------------------------

set signcolumn=yes
set virtualedit=block

let &viewdir = $VIMDIR . '/view'
let &viminfo = "!,'100,<50,s10,h"
let &viminfofile = $VIMDIR . '/viminfo'

nnoremap <C-W><C-F> :vsplit <C-R><C-P><CR>
nnoremap <Leader><C-L> <C-L>
nnoremap <Leader>D <Cmd>%d<CR>
nnoremap <Leader>V :setl <C-R>=&virtualedit =~# 'all' ? 'virtualedit=block' : 'virtualedit=all'<CR><CR>
nnoremap <Leader>la :ls!<CR>
nnoremap <Leader>lb :ls! %<CR>
nnoremap <Leader>lc :ls! +<CR>
nnoremap <Leader>ls :ls<CR>
nnoremap <Leader>lt :ls t<CR>
nnoremap <Leader>q <Cmd>close<CR>
nnoremap <Leader>sc <Cmd>new +setl\ bt=nofile\ bh=wipe\ noswf\ nobl<CR>
nnoremap Q <Nop>

" New lines
nnoremap [<Space> O<Esc>'[
nnoremap ]<Space> o<Esc>

" Open
nnoremap <Leader>ew :e<Space>
nnoremap <Leader>es :sp<Space>
nnoremap <Leader>ev :vs<Space>
nnoremap <Leader>et :tabe<Space>
nnoremap <Leader>ee <Cmd>e \| f<CR>
nnoremap <Leader>e0 <Cmd>e ++bin \| f<CR>
nnoremap <Leader>e1 <Cmd>e ++nobin \| f<CR>
nnoremap <Leader>E <Cmd>e! \| f<CR>

" Read / Filter
nnoremap <Leader>% :%!
nnoremap <Leader>ri :r!

" Readonly / Modifiable
nnoremap <Leader>ro :setl ro noma<CR>
nnoremap <Leader>ma :setl ma noro<CR>

" Sorting
xnoremap <silent> <Leader>ss :sort<CR>
xnoremap <silent> <Leader>su :sort u<CR>
xnoremap <silent> <Leader>sr :sort!<CR>
xnoremap <silent> <Leader>sb :!sortb<CR>

" Strip / Squash lines
xnoremap <silent> <Leader>ps :!striplns<CR>
nnoremap <silent> <Leader>ps :%!striplns<CR>
xnoremap <silent> <Leader>pS :!squashlns<CR>
nnoremap <silent> <Leader>pS :%!squashlns<CR>

" Help
nnoremap <Leader>h :tab help<Space>
nnoremap <Leader>H :tab lhelpgrep<Space>

" Diffs
xnoremap <silent> <Leader>do :diffget<CR>
nnoremap <silent> <Leader>do :.diffget<CR>
xnoremap <silent> <Leader>dp :diffput<CR>
nnoremap <silent> <Leader>dp :.diffput<CR>
nnoremap <Leader>du <Cmd>diffup!<CR>
nnoremap <Leader>dc <Cmd>diffoff!<CR>
nnoremap <Leader>dd <Cmd>exec &diff ? 'diffoff' : 'diffthis'<CR>

" ----------------------------------------

" Better :bdelete {{{

function! s:Bdelete(bang, rbeg, rend, ...) abort
    let newbuf = -1
    for bufref in empty(a:000) ? range(a:rbeg, a:rend) : a:000
        if type(bufref) == v:t_string && match(bufref, '^\d\+$') >= 0
            let bufref = str2nr(bufref)
        endif
        let target_buf = bufnr(bufref)
        if target_buf < 0
            call utils#echoError(printf('E94: No matching buffer for %s', bufref))
            continue
        endif
        if !bufloaded(target_buf)
            continue
        endif
        if empty(a:bang) && getbufvar(target_buf, '&mod')
            call utils#echoError(printf('E89: No write since last change for buffer %s (add ! to override)', target_buf))
            continue
        endif
        let srcwin = win_getid()
        for win in win_findbuf(target_buf)
            let [tab, winnr] = win_id2tabwin(win)
            let [jumps, jumpi] = getjumplist(winnr, tab)
            let [i, dstbuf] = [jumpi - 1, -1]
            while i >= 0
                let buf = jumps[i].bufnr
                if buf > 0 && buf != target_buf && bufloaded(buf)
                    let dstbuf = buf
                    break
                endif
                let i -= 1
            endwhile
            if dstbuf < 0
                if newbuf < 0 | let newbuf = bufadd('') | endif
                let &l:buflisted = 1
                let dstbuf = newbuf
            endif
            call win_gotoid(win)
            exec 'buffer' dstbuf
        endfor
        exec 'bdelete' . a:bang target_buf
        call win_gotoid(srcwin)
    endfor
endfunction

command! -nargs=* -range -addr=loaded_buffers -bang -complete=buffer
    \ Bdelete call s:Bdelete(<q-bang>, <line1>, <line2>, <f-args>)
nnoremap <C-Q> <Cmd>Bdelete<CR>

" }}}

" Capture command's output {{{

function! s:Run(system, cmd, input, mode = 1, mods = '') abort
    if a:system
        let out = system(a:cmd, a:input)
        let reg = 's'
    else
        try
            let list = &l:list
            let &l:list = 0
            let out = execute(a:cmd)[1:]
        finally
            let &l:list = list
        endtry
        let reg = 'e'
    endif
    call setreg(reg, out)
    if a:mode < 0
        redraw
        echo join(getreg(reg, 1, 1,), "\n")
        return
    endif
    if a:mode > 0
        exec a:mods 'new'
    endif
    setl bt=nofile bh=hide noswf nobl
    let b:run_system = a:system
    let b:run_cmd = a:cmd
    let b:run_input = a:input
    let b:run_title = (a:system ? '!' : ':') . a:cmd
    try
        setl ma noro ul=-1
        silent exec 'Keep %d_ | put' reg '| 1d_'
        if !a:system | %Sanitize | endif
    catch /:E353:/
    finally
        set ul<
        let v:statusmsg = b:run_title
    endtry
endfunction

command! -nargs=1 -count=1 -bang -complete=command Execute
    \ call utils#tryCatchCall('<SID>Run', 0, <q-args>, [], empty(<q-bang>) ? <count> > 0 : -1, <q-mods>)
nnoremap <Leader>xe :Execute<Space>
nnoremap <Leader>xE :Execute verb<Space>

command! -nargs=1 -count=1 -bang -complete=shellcmd System
    \ call utils#tryCatchCall('<SID>Run', 1, <q-args>, [], empty(<q-bang>) ? <count> > 0 : -1, <q-mods>)
command! -nargs=1 -bang -complete=shellcmd SystemRegister
    \ call utils#tryCatchCall('<SID>Run', 1, <q-args>, getreg(v:register, 1, 1), empty(<q-bang>) ? 1 : -1, <q-mods>)
command! -nargs=1 -range -bang -complete=shellcmd SystemRange
    \ call utils#tryCatchCall('<SID>Run', 1, <q-args>, getline(<line1>, <line2>), empty(<q-bang>) ? 1 : -1, <q-mods>)
nnoremap <Leader>xs :System<Space>
nnoremap <Leader>xS :System!<Space>
xnoremap <Leader>xs y:SystemRegister<Space>
xnoremap <Leader>xS y:SystemRegister!<Space>

function! s:Reload(bang) abort
    if exists('b:run_system')
        call s:Run(b:run_system, b:run_cmd, b:run_input, 0)
    else
        if &l:buftype =~# '^\(nofile\|quickfix\|terminal\)$'
            throw printf("\"%s\" buffer can't be reloaded", &l:buftype)
        endif
        silent exec 'Keep edit' . a:bang . '| file'
    endif
    let v:statusmsg = printf('[%s] %s', strftime('%H:%M:%S'), v:statusmsg)
    call utils#echo(utils#shortenCmdline(v:statusmsg))
endfunction

command! -bang -bar Reload call utils#tryCatchCall('<SID>Reload', <q-bang>)
nnoremap <Leader>rr <Cmd>Reload<CR>

function! s:ReloadT(bang, d) abort
    let d = str2nr(a:d)
    let d = d == 0 ? 1 : d
    try
        let v:statusmsg = ''
        while 1
            call s:Reload('')
            echon printf(' (every %ds)', d)
            if !empty(a:bang) | $ | endif
            exec 'sleep' d
        endwhile
    finally
        call utils#echo(utils#shortenCmdline(v:statusmsg))
    endtry
endfunction

command! -nargs=? -bang -bar ReloadT call utils#tryCatchCall('<SID>ReloadT', <q-bang>, <q-args>)
nnoremap <Leader>R <Cmd>ReloadT<CR>
nnoremap <Leader>F <Cmd>ReloadT!<CR>

" }}}

" Displaying options {{{

" global (e.g., 'cdpath')
"   - &g:opt and &l:opt is a single value
"
" local to buffer (e.g., 'readonly')
"   - &g:opt is a single value
"   - &l:opt is assigned to a buffer
"
" local to window (e.g., 'list')
"   - &g:opt is assigned to a window
"   - &l:opt is assigned to a window-buffer pair
"
" global or local to buffer (e.g., 'path')
"   - &g:opt is a single value
"   - &l:opt is assigned to a buffer with fallback to &g:opt
"
" global or local to window (e.g., 'statusline')
"   - &g:opt is a single value
"   - &l:opt is assigned to a window, with fallback to &g:opt
"
" --------------------------------------------------
"
" :set opt
"   - set both &g:opt and &l:opt
"   - in case of global-local option set &g:opt and reset &l:opt
"
" :set opt<
"   - let &l:opt = &g:opt
"   - in case of global-local option reset &l:opt
"
" :setl opt<
"   - let &l:opt = &g:opt

function! s:Option(opt) abort
    if exists('&' . a:opt)
        echo printf('&g:%s=%s', a:opt, eval('&g:' . a:opt))
        echo printf('&l:%s=%s', a:opt, eval('&l:' . a:opt))
    else
        call utils#echoError(printf('"%s" is not an option', a:opt))
    endif
endfunction

command! -nargs=1 -bar -complete=option Option call s:Option(<q-args>)
nnoremap <Leader>oo :Option<Space>

function! s:BufOrWinOptions(getvar) abort
    for opt in sort(keys(a:getvar('&')))
        let g = a:getvar('&g:' . opt)
        let l = a:getvar('&l:' . opt)
        if type(g) == v:t_number
            echo printf('%-15s%10s%10s', opt, g, l)
        else
            echo printf("%-15s\n  =%s\n  =%s", opt, g, l)
        endif
    endfor
endfunction

function! s:BufAndWinOptions() abort
    echo 'Buffer options (global/local):'
    echo '----------------------------------------'
    call s:BufOrWinOptions(function('getbufvar', ['']))
    echon "\n"
    echo 'Window options (global/local):'
    echo '----------------------------------------'
    call s:BufOrWinOptions(function('getwinvar', [0]))
endfunction

command! -count=1 -bar BufWinOptions <count>Execute call s:BufAndWinOptions()

" }}}

" Edit / Reload 'vimrc' {{{

nnoremap <silent> <Leader>rc :vsplit <C-R>=fnameescape(vimrc)<CR><CR>

try
function! s:VimrcReload() abort
    let winrestcmd = winrestcmd()

    new +setl\ bt=nofile\ bh=wipe\ noswf\ nobl
    exec 'source' fnameescape(g:vimrc)
    close

    "let winid = popup_create('VimrcReload', #{hidden: 1})
    "call win_execute(winid, 'source ' . fnameescape(g:vimrc))
    "call popup_close(winid)

    "let winids = map(getwininfo(), 'v:val.winid')
    "for opt in keys(getwinvar(0, '&'))
    "   let val = getwinvar(0, '&g:' . opt)
    "   for winid in winids
    "       call win_execute(winid, printf('let &g:%s = %s', opt, string(val)))
    "   endfor
    "endfor

    exec winrestcmd
    redraw
    call utils#echoWarn('vimrc reloaded')
endfunction
catch /:E127:/
endtry

command! -bar VimrcReload call s:VimrcReload()
nnoremap <Leader>so <Cmd>VimrcReload<CR>

" }}}

" Edit registers {{{

function! s:Register(regname, value) abort
    let regname = a:regname
    if empty(regname)
        let regname = '"'
        if &clipboard =~# 'unnamed' | let regname = '*' | endif
        if &clipboard =~# 'unnamedplus' | let regname = '+' | endif
    endif
    let value = substitute(a:value, '^=', '', '')
    call setreg(regname, value)
endfunction

command! -nargs=? -register Register call s:Register(<q-reg>, <q-args>)
nnoremap <Leader>re :Register <C-R>=v:register<CR> =<C-R>=getreg(v:register)<CR>

" }}}

" Execute the contents of register in visual mode {{{

function! s:VisualAt() range abort
    echo '@'
    let c = getchar()
    if type(c) == 0 | let c = nr2char(c) | endif
    let cmd = a:firstline . ',' . a:lastline . 'norm!@' . c
    exec cmd
    redraw
    echo ':' . cmd
endfunction

xnoremap @ :norm!@
xnoremap <silent> @ :call utils#tryCatchCall('<SID>VisualAt')<CR>

" }}}

" Formatting {{{

function! s:Format(ft = &ft) range abort
    let args = [a:firstline . ',' . a:lastline, '!format', '-s', &sw, '-t', &tw]
    if !empty(a:ft) | call extend(args, ['-f', a:ft]) | endif
    exec join(args)
endfunction

command! -nargs=? -range -bar Format silent Keep <line1>,<line2> call s:Format(<f-args>)
xnoremap <silent> <Leader>fo :Format<CR>
nnoremap <silent> <Leader>fo :%Format<CR>

xnoremap <silent> <Leader>px :Format xml<CR>
nnoremap <silent> <Leader>px :%Format xml<CR>

xnoremap <silent> <Leader>pj :Format json<CR>
nnoremap <silent> <Leader>pj :%Format json<CR>

" }}}

" MoveToTab {{{

function! s:MoveToTab(next) abort
    if tabpagenr('$') == 1 && winnr('$') == 1 | return | endif
    let [tab, srcwin] = [tabpagenr(), win_getid()]
    if a:next ? tab < tabpagenr('$') : tab > 1
        exec a:next ? 'tabnext' : 'tabprev'
        botright vsplit
    else
        if winnr('$') == 1 | return | endif
        exec a:next ? 'tabnew' : '0tabnew'
    endif
    exec 'buffer' winbufnr(srcwin)
    let dstwin = win_getid()
    call win_gotoid(srcwin)
    close!
    call win_gotoid(dstwin)
endfunction

command! -bar MoveToNextTab call s:MoveToTab(1)
command! -bar MoveToPrevTab call s:MoveToTab(0)
nnoremap <C-W><M-l> <Cmd>MoveToNextTab<CR>
nnoremap <C-W><M-h> <Cmd>MoveToPrevTab<CR>

" }}}

" Next/PrevClosedFold <https://stackoverflow.com/questions/9403098/is-it-possible-to-jump-to-closed-folds-in-vim> {{{

function! s:MoveToClosedFold(next) abort
    let cmd = 'normal! z' . (a:next ? 'j' : 'k')
    let view = winsaveview()
    let [lnum0, lnum, isopen] = [0, view.lnum, 1]
    while lnum != lnum0 && isopen
        exec cmd
        let [lnum0, lnum] = [lnum, line('.')]
        let isopen = foldclosed(lnum) < 0
    endwhile
    if isopen | call winrestview(view) | endif
endfunction

command! -bar NextClosedFold call s:MoveToClosedFold(1)
command! -bar PrevClosedFold call s:MoveToClosedFold(0)
nnoremap <Leader>zj <Cmd>NextClosedFold<CR>
nnoremap <Leader>zk <Cmd>PrevClosedFold<CR>

" }}}

" Keep cursor / window position, last search pattern, and the others {{{

function! s:Keep(cmd) abort
    let view = winsaveview()
    exec 'keepa keepj keepm keepp' a:cmd
    call winrestview(view)
endfunction

command! -nargs=1 -complete=command Keep call s:Keep(<q-args>)

" }}}

" Starts diff of current buffer with another file {{{

function! s:DiffTo(file) abort
    let file = fnamemodify(a:file, ':p')
    if isdirectory(file)
        call utils#echoError(printf('"%s" is a directory', fnamemodify(file, ':h')))
        return
    endif
    if !filereadable(file)
        call utils#echoError(printf('"%s" is not readable', file))
        return
    endif
    vnew
    exec 'read ++edit' fnameescape(file) | 0d_
    exec 'setl bt=nofile bh=wipe noswf nobl noma ft=' . getbufvar('#', '&ft')
    exec 'silent file DiffTo:\ ' . fnameescape(fnamemodify(file, ':~'))
    diffthis
    wincmd p
    diffthis
endfunction

command! -nargs=1 -complete=file DiffTo call s:DiffTo(<q-args>)
nnoremap <Leader>df :DiffTo <C-R>=expand('%')<CR>

" }}}

" ToText {{{

function! s:ToText(ft = &ft) range abort
    let args = [a:firstline . ',' . a:lastline, '!totext', '-s', &sw, '-t', &tw]
    if !empty(a:ft) | call extend(args, ['-f', a:ft]) | endif
    exec join(args)
endfunction

command! -nargs=? -range=% -bar ToText silent <line1>,<line2> call s:ToText(<f-args>)

" }}}

" Toggles translation of ASCII meta escape prefix encoding to 8 bit meta encoding {{{

function! s:MetaLess(cmd) abort
    exec a:cmd
endfunction

if !has('nvim')

function! s:MetaSetup(enable) abort
    for c in map(range(1, 126), 'nr2char(v:val)')
        if stridx('|"', c) >= 0
            let c = '\' . c
        elseif stridx("\x09\x0a\x16 >[]", c) >= 0
            continue
        endif
        let kc = printf('<M-%s>', c)
        exec printf('set %s=%s', kc, a:enable ? "\e" . c : '')
        if empty(maparg(kc, 'i')) | exec printf('inoremap %s <Nop>', kc) | endif
        if empty(maparg(kc, 'c')) | exec printf('cnoremap %s <Nop>', kc) | endif
    endfor
    let g:meta_enabled = a:enable
    if !has('vim_starting')
        call utils#echoWarn('meta ' . (g:meta_enabled ? 'on' : 'off'))
    endif
endfunction

function! s:MetaLess(cmd) abort
    if g:meta_enabled
        silent call s:MetaSetup(0)
        exec a:cmd
        silent call s:MetaSetup(1)
    else
        exec a:cmd
    endif
endfunction

command! -bar MetaToggle call s:MetaSetup(!get(g:, 'meta_enabled', 0))
nnoremap <Leader>mm <Cmd>MetaToggle<CR>
silent call s:MetaSetup(1)

endif

" }}}

" Walks through list of colorschemes (q/C-C=quit, k=prev, default=next) {{{

function! s:Themes() abort
    let themes = ['luciusblack', 'hybrid', 'bclear']
    let [i, lasti] = [get(s:, 'themes_last_index'), len(themes) - 1]
    while 1
        exec 'colorscheme' themes[i]
        redraw | echo themes[i]
        let c = getchar()
        if c == 3 || c == 113
            break
        elseif c == 107
            let i = i > 0 ? i - 1 : lasti
        else
            let i = i < lasti ? i + 1 : 0
        endif
    endwhile
    let s:themes_last_index = i
    redraw | echo
endfunction

command! -bar Themes call s:Themes()
nnoremap <Leader>th <Cmd>Themes<CR>

" }}}

" Write with elevated privileges {{{

function! s:Write(filename = expand('%')) abort
    if empty(a:filename)
        call utils#echoError('E32: No file name')
        return
    endif
    exec 'silent write !sudo tee >/dev/null' shellescape(a:filename, 1)
    edit!
endfunction

command! -nargs=? -bar W call s:Write(<f-args>)

" }}}

" Zoom / Restore window {{{

function! s:ZoomToggle() abort
    if get(t:, 'zoomed')
        exec t:zoom_winrestcmd
        let t:zoomed = 0
    else
        let t:zoom_winrestcmd = winrestcmd()
        resize
        vert resize
        let t:zoomed = 1
    endif
endfunction

command! -bar ZoomToggle call s:ZoomToggle()
nnoremap <M-m> <Cmd>ZoomToggle<CR>
nnoremap <M-z> <Cmd>ZoomToggle<CR>

" }}}

" ----------------------------------------

command! -nargs=? -range Split
    \ call utils#tryCatch(
    \     printf('Keep <line1>,<line2>s/%s/\r/ge',
    \         !empty(<q-args>) ? escape(<q-args>, '/') : '\s\+'
    \     )
    \ )

command! -nargs=? -range Join
    \ call utils#tryCatch(
    \     printf('Keep <line1>,%ds/\n/%s/ge',
    \         <line2> > <line1> ? <line2> - 1 : <line2>,
    \         !empty(<q-args>) ? escape(<q-args>, '/&') : ' '
    \     )
    \ )

command! -count=1 -bar PackPath exec '<count>Execute set pp' | exec 'normal! df=' | Split,
command! -count=1 -bar RuntimePath exec '<count>Execute set rtp' | exec 'normal! df=' | Split,
command! -count=1 -bar ScriptNames <count>Execute scriptnames

command! -count=1 -bar Registers <count>Execute registers
nnoremap <Leader>rg :Registers<CR>

command! -bar DelDirs Keep g/\/$/d

command! -range -bar Sanitize silent Keep <line1>,<line2> s/\s\+$//e
xnoremap <silent> <Leader>pp :Sanitize<CR>
nnoremap <silent> <Leader>pp :%Sanitize<CR>

nnoremap <Leader>== <Cmd>Keep normal! gg=G<CR>
nnoremap <Leader>gq <Cmd>Keep normal! gggqG<CR>

xnoremap <silent> <Leader>uu :SystemRange! urls -o<CR>
nnoremap <silent> <Leader>uu :.SystemRange! urls -o<CR>
nnoremap <silent> <Leader>uU :<C-R>=line('w0')<CR>,<C-R>=line('w$')<CR>SystemRange! urls -o<CR>

xnoremap <silent> <Leader>uy :SystemRange! urls -y<CR>
nnoremap <silent> <Leader>uy :.SystemRange! urls -y<CR>
nnoremap <silent> <Leader>uY :<C-R>=line('w0')<CR>,<C-R>=line('w$')<CR>SystemRange! urls -y<CR>

nnoremap <Leader>gs :vert System git show HEAD:./

" ----------------------------------------

let loaded_2html_plugin = 1
let loaded_getscriptPlugin = 1
let loaded_logiPat = 1
let loaded_netrwPlugin = 1
let loaded_rrhelper = 1
let loaded_spellfile_plugin = 1
let loaded_vimballPlugin = 1

if has('nvim')
    let loaded_man = 1
    let loaded_remote_plugins = 1
    let loaded_tutor_mode_plugin = 1
endif

let qf_disable_statusline = 1

packadd! ansiesc
packadd! cfilter
packadd! colorschemes
packadd! matchit
packadd! termdebug

filetype plugin indent on
if !exists('syntax_on')
    syntax enable
endif

ColorsReset

augroup vimrc_base
    autocmd!

    autocmd BufEnter,BufWinEnter * match none
    autocmd FileChangedRO * setl noro
    autocmd QuickFixCmdPost l* lwindow
    autocmd QuickFixCmdPost [^l]* cwindow

    autocmd CmdwinEnter *
        \  call utils#bufSpecial()
        \| noremap <buffer> <C-J> <C-C><C-E>

    autocmd BufReadPost *
        \  if line("'\"") >= 1 && line("'\"") <= line('$') && &ft !~# 'commit'
        \|     exec 'normal! g`"'
        \| endif

    autocmd SwapExists * let v:swapchoice = 'o' | setl noma

    function! s:TerminalSetup() abort
        call utils#bufSpecial()
        setl list
        let &l:stl = '%{%' . expand('<SID>') . 'TerminalStatusline()%}'
    endfunction

    function! s:TerminalStatusline() abort
        let stl = '%n'
        let bin = matchstr(expand('%'), '\v^term://%(.{-}//%(\d+:)?)?\zs.*')
        if empty(bin)
            let stl .= ' %<%f'
        else
            if bin == exepath(&shell) | let bin = &shell | endif
            let stl .= printf(' !%s', bin)
        endif
        if exists('b:term_title') && match(b:term_title, '^term://') < 0
            let stl .= printf(' [%s]', b:term_title)
        endif
        if mode() == 'n'
            let stl .= '%= %6(%l:%v%) %P'
        endif
        return stl
    endfunction

    if has('nvim')
        autocmd TermOpen,TermLeave * call s:TerminalSetup()
        autocmd TermOpen * startinsert
        autocmd TermEnter * setl nolist
    else
        autocmd TerminalWinOpen * call s:TerminalSetup()
        autocmd TermChanged * silent call s:MetaSetup(meta_enabled)
    endif

    autocmd BufWritePost conky.conf !killall -USR1 conky
    autocmd BufWritePost ~/.Xresources !xrdb -screen -load ~/.Xresources

    autocmd FileType diff call utils#bufSpecial()
    autocmd FileType mail call utils#bufSpecial() | setl tw=72
    autocmd FileType make setl ts=4 noet
    autocmd FileType man call utils#bufSpecial() | setl noma ts=8
    autocmd FileType rst setl ts=8 sw=3 fdm=manual foldtext&
    autocmd FileType tar call utils#bufSpecial()
    autocmd FileType yaml setl ts=2
    autocmd FileType zip call utils#bufSpecial()
    autocmd FileType {c,cpp}{,.*} let &l:path = '.,,**,/usr/include'
augroup END

" ----------------------------------------

hi def link Boolean                     Constant
hi def link Character                   Constant
hi def link Conditional                 Statement
hi def link Debug                       Special
hi def link Define                      PreProc
hi def link Delimiter                   Special
hi def link Exception                   Statement
hi def link Float                       Number
hi def link Function                    Identifier
hi def link HelpCommand                 Statement
hi def link HelpExample                 Statement
hi def link Include                     PreProc
hi def link Keyword                     Statement
hi def link Label                       Statement
hi def link Macro                       PreProc
hi def link Number                      Constant
hi def link Operator                    Statement
hi def link PreCondit                   PreProc
hi def link Repeat                      Statement
hi def link SpecialChar                 Special
hi def link SpecialComment              Special
hi def link StorageClass                Type
hi def link String                      Constant
hi def link Structure                   Type
hi def link Tag                         Special
hi def link Typedef                     Type
hi def link asciidocQuotedEmphasized    PreProc
hi def link diffBDiffer                 Statement
hi def link diffCommon                  Statement
hi def link diffDiffer                  Statement
hi def link diffIdentical               Statement
hi def link diffIndexLine               Type
hi def link diffIsA                     Statement
hi def link diffNoEOL                   Statement
hi def link diffOnly                    Statement
hi def link diffRemoved                 Constant
hi def link htmlBold                    Normal
hi def link htmlEndTag                  htmlTagName
hi def link htmlItalic                  Normal
hi def link htmlLink                    Function
hi def link htmlSpecialTagName          htmlTagName
hi def link htmlTag                     htmlTagName
hi def link markdownItalic              PreProc
hi def link xmlEndTag                   Statement
hi def link xmlTag                      Statement
hi def link xmlTagName                  Statement

" Nvim LSP
hi def link LspDiagnosticsDefaultHint LspDiagnosticsDefaultInformation
hi def link LspDiagnosticsFloatingHint LspDiagnosticsFloatingInformation
hi def link LspDiagnosticsSignHint LspDiagnosticsSignInformation
hi def link LspDiagnosticsUnderlineHint LspDiagnosticsUnderlineInformation
hi def link LspDiagnosticsVirtualTextHint LspDiagnosticsVirtualTextInformation
